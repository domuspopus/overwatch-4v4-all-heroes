settings
{
	main
	{
		Description: "All new OW2 heroes. Code: 48CYD\n- Lobby balancing.\n- Hammond can grapple air.\n- Ana can self-ult.\n- Junk can ult mid-air.\n- D.Va doesn't get infinite nukes.\n- Restricted airspace (trolling prevention).\n\nv1.8.1dev (12-Feb-26). All changes and info at:\ngithub.com/domuspopus/overwatch-4v4-all-heroes\nAlso at: workshop.codes/48CYD"
		Mode Name: "4v4 All Heroes (J-edit)"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: Paused
		Match Voice Chat: Enabled
		Max Team 1 Players: 4
		Max Team 2 Players: 4
		Return To Lobby: Never
		Swap Teams After Match: No
		Team Balancing: After A Game
	}

	modes
	{
		Elimination
		{
			enabled maps
			{
				Workshop Island 972777519512063901
				Workshop Island Night 972777519512064579
			}
		}

		General
		{
			Allow Hero Switching: Off
			Capture Objective Tiebreaker: Off
			Game Mode Start: Immediately
			Respawn As Random Hero: On
			Respawn Time Scalar: 0%
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 25%
			Role Passives: Off
			Spawn With Ultimate Ready: On
			Ultimate Generation: 200%
			Ultimate Generation - Combat: 130%

			Anran
			{
				Spawn With Ultimate Ready: Off
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 30%
			}

			Cassidy
			{
				Spawn With Ultimate Ready: Off
				Ultimate Generation - Combat Deadeye: 200%
				Ultimate Generation - Passive Deadeye: 10%
			}

			D.Va
			{
				Self Destruct Knockback Scalar: 200%
				Spawn With Ultimate Ready: Off
			}

			Domina
			{
				Barrier Array Cooldown Time: 50%
			}

			Freja
			{
				Quick Dash Cooldown Time: 50%
				Take Aim Cooldown Time: 75%
			}

			Junker Queen
			{
				Commanding Shout Cooldown Time: 30%
				Health: 85%
			}

			Junkrat
			{
				Concussion Mine Knockback Scalar: 120%
			}

			Lifeweaver
			{
				Petal Platform Health: 25%
				Tree of Life Health: 50%
			}

			Mauga
			{
				Ultimate Duration: 65%
			}

			Mei
			{
				Health: 90%
			}

			Mercy
			{
				Health: 85%
				Resurrect Cooldown Time: 60%
			}

			Moira
			{
				Biotic Orb Cooldown Time: 45%
				Fade Cooldown Time: 35%
				Health: 85%
				Spawn With Ultimate Ready: Off
			}

			Orisa
			{
				Health: 65%
			}

			Reinhardt
			{
				Ultimate Generation - Passive Earthshatter: 400%
			}

			Roadhog
			{
				Health: 65%
				Spawn With Ultimate Ready: Off
				Take a Breather Recharge Rate: 350%
				Whole Hog Knockback Scalar: 80%
			}

			Soldier: 76
			{
				Spawn With Ultimate Ready: Off
				Ultimate Duration: 50%
			}

			Venture
			{
				Burrow Cooldown Time: 45%
			}

			Widowmaker
			{
				Ammunition Clip Size Scalar: 150%
				Grappling Hook Cooldown Time: 10%
				Health: 110%
				Movement Speed: 140%
				Venom Mine Cooldown Time: 5%
			}

			Winston
			{
				Barrier Projector Cooldown Time: 35%
				Damage Dealt: 130%
				Health: 75%
			}

			Wrecking Ball
			{
				Grappling Claw Knockback Scalar: 115%
				Health: 65%
			}

			Zarya
			{
				Health: 70%
				Particle Barrier Cooldown Time: 60%
			}
		}
	}
}

variables
{
	global:
		0: IsRoundActive
		1: IsRoundStart
		2: GTextIDS
		3: POWERUP_HPPERCENT
		4: POWERUP_DAMAGEPERCENT
		5: POWERUP_HPPERCENT_SOLO
		6: POWERUP_DAMAGEPERCENT_SOLO
		7: Powerup_PlayersNumAdvantage
		8: MAPBOUNDRY_VERTICAL
		9: MAPBOUNDRY_HORIZONTAL
		10: ServerLoadVisibleTo
		11: TimeLimit1v1_Triggers
		12: HUDTipColor
		14: GTemp
		15: RealPlayers
		16: RealAlivePlayers
		17: GTempArray1
		18: Powerup_EmpoweredTeam
		19: LobbyBalance_Team1Newbie
		20: LobbyBalance_WinStreak
		21: LobbyBalance_WinStreakID
		22: LobbyBalance_VictorTeam
		23: Powerup_HUDText
		24: FEATURE_ANA_SELF_ULT
		25: FEATURE_JUNK_AIR_ULT
		26: FEATURE_HAMMOND_ICICLE_GRAPPLE
		27: FEATURE_HAMMOND_BUFF_PILEDRIVER
		28: LobbyBalance_Paused
		29: ChaserVar1
		44: DBGIndevHeroes
		45: DBGMovedPlayersNum
		46: DBGRoundNum
		47: DBGAllowHeroSelect
		48: DBGMsg
		49: DBGBotShooting
		50: DBG

	player:
		0: PTextIDS
		1: Hammond_GrappleIsOn
		2: Hammond_IciclePos
		3: ChaserVar1
		4: PTemp
		5: Echo_JustDuplicated
		6: Echo_DupeUlted
		7: ChaserVar2
		8: PTempArray1
		9: Hammond_PiledriverHarmFlag
}

subroutines
{
	0: FindRealPlayers
	1: LobbyBalance_Notify
}

rule("PROJECT INFO")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Some implementation details and notes are available at (click to show): https://github.com/domuspopus/overwatch-4v4-all-heroes/wiki"
		Abort;
		"Top PTemp=23 GTemp=16 GTextIDS=1 PTextIDS=1"
		Abort;
	}
}

rule("Base: Set global variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Auto-balancing variables. Bumps percentage of HP / damage of each player in smaller team."
		Global.POWERUP_HPPERCENT = 25;
		Global.POWERUP_DAMAGEPERCENT = 30;
		"Same as above but these will apply if team only has 1 player"
		Global.POWERUP_HPPERCENT_SOLO = 30;
		Global.POWERUP_DAMAGEPERCENT_SOLO = 50;
		"Map boundaries"
		Global.MAPBOUNDRY_VERTICAL = 25;
		Global.MAPBOUNDRY_HORIZONTAL = 45;
		"Features (can be disabled to deactivate and hide related HUD tips, not exposed as settings intentionally)"
		Global.FEATURE_ANA_SELF_ULT = True;
		Global.FEATURE_JUNK_AIR_ULT = True;
		Global.FEATURE_HAMMOND_ICICLE_GRAPPLE = True;
		Global.FEATURE_HAMMOND_BUFF_PILEDRIVER = True;
		"Misc"
		Disable Built-In Game Mode Announcer;
		Global.ServerLoadVisibleTo = Empty Array;
		Global.DBGRoundNum = 1;
	}
}

rule("Base: Skip hero select, initiate round start variables")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		"Disable inspector in live game"
		If(!Global.DBG);
			Disable Inspector Recording;
		End;
		"Allow time to select in debug mode"
		If(Global.DBGAllowHeroSelect);
			Set Match Time(Global.DBGAllowHeroSelect);
			Wait(Global.DBGAllowHeroSelect, Ignore Condition);
		End;
		Global.Powerup_EmpoweredTeam = Null;
		Global.LobbyBalance_VictorTeam = -1;
		"This skips the selection"
		Set Match Time(0);
		"Allow time for game to select hero for player and initiate round"
		Wait(0.250, Ignore Condition);
		Global.IsRoundActive = True;
		Global.IsRoundStart = True;
		Log To Inspector(Custom String(">>> round #{0} start", Match Round));
		Wait(0.250, Ignore Condition);
		Global.IsRoundStart = False;
	}
}

rule("Base: Round end (cleanup)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Between Rounds == True;
	}

	actions
	{
		Log To Inspector(Custom String(">>> round end"));
		If(Team Score(Team 1) > 0);
			Global.LobbyBalance_VictorTeam = Team 1;
		Else If(Team Score(Team 2) > 0);
			Global.LobbyBalance_VictorTeam = Team 2;
		Else;
			Global.LobbyBalance_VictorTeam = Null;
		End;
		Set Team Score(All Teams, 0);
		Global.IsRoundActive = False;
		Global.Powerup_PlayersNumAdvantage = 0;
		Global.DBGRoundNum += 1;
		Stop All Healing Modifications;
		Stop All Damage Modifications;
		Stop All Damage Over Time(All Players(All Teams));
		Stop Forcing Player Position(All Players(All Teams));
		Reset Player Hero Availability(All Players(All Teams));
		Set Damage Dealt(All Players(All Teams), 100);
		Set Max Health(All Players(All Teams), 100);
		Allow Button(All Players(All Teams), Button(Secondary Fire));
		Destroy HUD Text(Global.GTextIDS[0]);
		Set Knockback Dealt(All Players(All Teams), 100);
		Set Knockback Received(All Players(All Teams), 100);
		Destroy All In-World Text;
		Destroy All Progress Bar In-World Text;
		Destroy All Effects;
		Stop Scaling Player(All Players(All Teams));
		Set Move Speed(All Players(All Teams), 100);
		Remove All Health Pools From Player(All Players(All Teams));
		Set Gravity(All Players(All Teams), 100);
	}
}

rule("Base: Round end (cleanup - per player)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsRoundActive != True;
	}

	actions
	{
		"Destroy bots in slots 4-11, these are used for temporary dummy bots for faux abilities etc."
		If(Is Dummy Bot(Event Player) && Slot Of(Event Player) > 3);
			Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
		End;
		Destroy HUD Text(Event Player.PTextIDS[0]);
		Destroy HUD Text(Event Player.PTextIDS[1]);
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Stop Chasing Player Variable(Event Player, ChaserVar2);
		Event Player.Echo_JustDuplicated = Null;
		Event Player.Hammond_PiledriverHarmFlag = Null;
	}
}

rule("Base: Prevent heroes flying away")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Y Component Of(Position Of(Event Player)) > Global.MAPBOUNDRY_VERTICAL || Absolute Value(X Component Of(Position Of(
			Event Player))) > Global.MAPBOUNDRY_HORIZONTAL || Absolute Value(Z Component Of(Position Of(Event Player)))
			> Global.MAPBOUNDRY_HORIZONTAL) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Small Message(Event Player, Custom String("  Don't stray too far {0} {1}", Icon String(Warning), Ability Icon String(Hero(Mercy),
			Button(Ability 1))));
		Set Status(Event Player, Null, Frozen, 2);
		Wait(1.900, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Base: Punish for stalling outside the map")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Global.IsRoundActive == True;
		Y Component Of(Position Of(Event Player)) < -0.100;
	}

	actions
	{
		Wait Until(Y Component Of(Position Of(Event Player)) > -0.100, Hero Of(Event Player) == Hero(Widowmaker) ? 5 : 3);
		Abort If(Y Component Of(Position Of(Event Player)) > -0.100);
		Event Player.PTemp[23] = 5;
		Create HUD Text(Event Player, Null, Null,
			Event Player.PTemp[23] > 0 ? Custom String("\nGet back: {0}", Event Player.PTemp[23]) : Custom String("\nGet back or die"),
			Top, 1, Color(White), Color(White), Custom Color(250, 55, 65, 255), String, Default Visibility);
		Event Player.PTextIDS[1] = Last Text ID;
		While(True);
			If(
				!Is Alive(Event Player) ||
				!Global.IsRoundActive ||
				(
					Y Component Of(Position Of(Event Player)) > -0.100 &&
					Absolute Value(X Component Of(Position Of(Event Player))) < 19.5 &&
					Absolute Value(Z Component Of(Position Of(Event Player))) < 19.5
				)
			);
				Destroy HUD Text(Event Player.PTextIDS[1]);
				Stop Healing Modification(Event Player.PTemp[22]);
				Abort;
			End;
			If(Event Player.PTemp[23] == 0 && Number Of Players(Team Of(Event Player)) == 1);
				Small Message(All Players(All Teams), Custom String("  {0} killing {1}", Icon String(Poison), Event Player));
				Start Healing Modification(Event Player, All Players(All Teams), 25, None);
				Event Player.PTemp[22] = Last Healing Modification ID;
			End;
			If(Event Player.PTemp[23] <= 0);
				Damage(Event Player, Null, Max Health(Event Player) * 0.04);
			End;
			Event Player.PTemp[23] -= 1;
			Wait(Event Player.PTemp[23] > 0 ? 1 : .3, Ignore Condition);
		End;
	}
}

rule("Base: Prevent premature game completion and skip victory screen")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBG != True;
		Is Waiting For Players != True;
		(Number Of Players(Team 1) == 0 || Number Of Players(Team 2) == 0) == True;
	}

	actions
	{
		Call Subroutine(FindRealPlayers);
		If(Count Of(Global.RealPlayers) == 1);
			Small Message(All Players(All Teams), Custom String("  Everyone left - restarting..."));
			Wait(1.500, Ignore Condition);
			"Skip victory screen on default victory when all but one players leave"
			Restart Match;
		Else;
			Global.GTemp[1] = Last Of(All Players(All Teams));
			Log To Inspector(Custom String("immediately moving \"{0}\" to {1}", Global.GTemp[1], Opposite Team Of(Team Of(Global.GTemp[1]))));
			"XXX: it might make sense to also end match by declaring draw but that somehow doesn't trigger IsBetweenRounds (in this case) and no cleanup happens which is an issue"
			Global.DBGMovedPlayersNum += 1;
			Move Player to Team(Global.GTemp[1], Empty Array, -1);
			Move Player to Team(Global.GTemp[1], Opposite Team Of(Team Of(Global.GTemp[1])), -1);
		End;
	}
}

rule("Texts / HUD: Create permanent UI / HUD elements")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Global tips and HUDs"
		Create HUD Text(Array Contains(Global.ServerLoadVisibleTo, Custom String("{0}", Local Player)) ? Local Player : Null, Null,
			Custom String("{0}% AVG {1}% PK, {2}",
			Server Load Average, Server Load Peak,
				Custom String("{0}v{1}, {2}",
				Number Of Players(Team 1), Number Of Players(Team 2),
					Custom String("{0}++, R{1}/{2}",
					Global.Powerup_EmpoweredTeam ? Global.Powerup_EmpoweredTeam : Custom String("None"), Match Round,
						Custom String("{0}, PM{1}, SK{2}",
						Global.DBGRoundNum, Global.DBGMovedPlayersNum,
							Custom String("{0}{1}{2}",
							String Slice(Global.LobbyBalance_WinStreakID, 0, 1),
							Global.LobbyBalance_WinStreak,
							Global.LobbyBalance_Paused ? Custom String("P") : Custom String("")
		))))), Null, Right, -1, Null, Custom Color(255, 255, 255, 80), Null, Visible To String and Color, Visible Always);
		Create HUD Text(Array Contains(Global.ServerLoadVisibleTo, Custom String("{0}", Local Player)) ? Local Player : Null, Null,
			Custom String("HOST={0}", Host Player), Null, Right, -1, Null, Custom Color(255, 255, 255, 80), Null,
			Visible To String and Color, Visible Always);
		Create HUD Text(Local Player, Null, Custom String("v1.8.1dev"), Null, Right, 0, Null, Custom Color(255, 255, 255, 80), Null,
			Visible To String and Color, Visible Always);
		Create HUD Text(Team Of(Local Player) == Global.Powerup_EmpoweredTeam ? Local Player : Null, Null, Null, Global.Powerup_HUDText,
			Left, 10, Null, Null, Color(Lime Green), Visible To and String, Visible Never);
		"NOTE: Don't use local player for fixed tips that everyone should see between rounds, they wont show to dead players spectating through teammate"
		Create HUD Text(Filtered Array(All Players(All Teams), !Global.IsRoundActive || Is Dead(Current Array Element)), Null, Null,
			Custom String("Hero tips"), Left, 1, Null, Null, Color(Lime Green), Visible To, Visible Always);
		"Show hero specific tips and gather them into a list"
		Global.GTempArray1 = Empty Array;
		If(True);
			Global.GTempArray1[0] = Custom String("{0} {1} Armor on ultimate     ", Hero Icon String(Hero(Hanzo)), Hero Icon String(Hero(Widowmaker)));
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && (Hero Of(Local Player) == Hero(Widowmaker) || Hero Of(
				Local Player) == Hero(Hanzo)) ? Local Player : Null, Null, Global.GTempArray1[0], Null, Left, 3, Null, Global.HUDTipColor,
				Null, Visible To and Color, Visible Never);
		End;
		If(Global.FEATURE_ANA_SELF_ULT);
			Global.GTempArray1[1] = Custom String("{0} {1} Can self-ultimate      ", Hero Icon String(Hero(Ana)), Ability Icon String(Hero(Ana), Button(Ultimate)));
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Ana) ? Local Player : Null, Null,
				Global.GTempArray1[1], Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		If(Global.FEATURE_JUNK_AIR_ULT);
			Global.GTempArray1[2] = Custom String("{0} {1} Can ultimate mid-air", Hero Icon String(Hero(Junkrat)), Ability Icon String(Hero(Junkrat), Button(
				Ultimate)));
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Junkrat) ? Local Player : Null,
				Null, Global.GTempArray1[2], Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Junkrat) && Y Component Of(
			Position Of(Local Player)) < -1 ? Local Player : Null, Null, Custom String("{0} {1} More mines (on fall) ", Hero Icon String(
			Hero(Junkrat)), Ability Icon String(Hero(Junkrat), Button(Ability 1))), Null, Left, 2, Null, Global.HUDTipColor, Null,
			Visible To and Color, Visible Never);
		If(Global.FEATURE_HAMMOND_ICICLE_GRAPPLE);
			Global.GTempArray1[3] = Custom String("{0} {1} Can grapple air / sky", Hero Icon String(Hero(Wrecking Ball)), Ability Icon String(Hero(
				Wrecking Ball), Button(Secondary Fire)));
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				&& Local Player.Hammond_GrappleIsOn ? Local Player : Null, Null, Custom String("{0} (NOT NOW)", Global.GTempArray1[3]), Null, Left, 2, Null, Custom Color(255, 255, 255, 50), Null, Visible To and Color, Visible Never);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				&& !Local Player.Hammond_GrappleIsOn ? Local Player : Null, Null, Custom String("{0} (HOLD)         ", Global.GTempArray1[3]
				), Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		If(Global.FEATURE_HAMMOND_BUFF_PILEDRIVER);
			Global.GTempArray1[4] = Custom String("{0} {1} Stronger piledriver ", Hero Icon String(Hero(Wrecking Ball)), Ability Icon String(Hero(
				Wrecking Ball), Button(Crouch)));
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				? Local Player : Null, Null, Custom String("{0}                       ", Global.GTempArray1[4]), Null, Left, 3, Null,
				Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		"Create HUDs of all hero tips as a big list visible between rounds"
		Global.GTemp[2] = 0;
		While(Global.GTemp[2] < Count Of(Global.GTempArray1));
			If(Global.GTempArray1[Global.GTemp[2]]);
				Create HUD Text(Filtered Array(All Players(All Teams), !Global.IsRoundActive || Is Dead(Current Array Element)), Null,
					Global.GTempArray1[Global.GTemp[2]], Null, Left, 2, Null, Color(White), Null, Visible To, Visible Always);
			End;
			Global.GTemp[2] += 1;
		End;
		"HUD top spacing"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("\n\n\n"), Left, -1, Null, Null, Color(White), Visible To,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("\n\n\n"), Top, -1, Null, Null, Color(White), Visible To,
			Default Visibility);
		"Tips in config page"
		Skip If(Workshop Setting Combo(Custom String("2. Information"), Custom String(
			"Toggle automatic lobby balancing via <Interact> + <Primary Fire> + <Secondary Fire>"), 0, Array(Custom String(
			"I understand")), 0), 0);
		Skip If(Workshop Setting Combo(Custom String("2. Information"), Custom String(
			"Toggle debug HUD visibility via <Interact> + <Reload>"), 0, Array(Custom String("I understand")), 0), 0);
	}
}

rule("Misc: HUD tip highlight")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsRoundActive == True;
	}

	actions
	{
		Global.HUDTipColor = Color(Orange);
		Wait(2, Ignore Condition);
		Global.HUDTipColor = Color(White);
	}
}

rule("Misc: Cleanup utility dummies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Although very rare, it is possible for a utility dummy (e.g. icicle grapple mei dummy) to not be deleted during game if the rule handling her is aborted (e.g. player leaving)"
		Is Dummy Bot(Event Player) == True;
		Slot Of(Event Player) > 3;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
	}
}

rule("Misc: Pre-game ult generation")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	conditions
	{
		"For the first ~3 seconds of the round ultimates to not generate so we have to calc it manually for some heroes during this"
		Global.IsRoundActive == True;
		Is Game In Progress == False;
	}

	actions
	{
		If(Hero Of(Event Player) == Hero(Soldier: 76));
			"Soldiers normal rounds do ~18 damage, we take this much for a +1% to charge"
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + Round To Integer(Event Damage / 20, Up));
		Else If(Hero Of(Event Player) == Hero(Cassidy));
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 1);
		End;
	}
}

rule("HP/Damage Balance: Powerup players belonging to smaller team")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsRoundStart == True;
		Number Of Players(Team Of(Event Player)) < Number Of Players(Opposite Team Of(Team Of(Event Player)));
	}

	actions
	{
		"This ensures rule is only called for one player in smaller team (since it will apply to everyone anyway)"
		Abort If(Global.Powerup_PlayersNumAdvantage > 0);
		Global.Powerup_PlayersNumAdvantage = Number Of Players(Opposite Team Of(Team Of(Event Player))) - Number Of Players(Team Of(
			Event Player));
		Global.GTemp[9] = Global.POWERUP_HPPERCENT * Global.Powerup_PlayersNumAdvantage;
		Global.GTemp[10] = Global.POWERUP_DAMAGEPERCENT * Global.Powerup_PlayersNumAdvantage;
		If(Number Of Players(Team Of(Event Player)) == 1);
			"Solo team override"
			Global.GTemp[9] = Global.POWERUP_HPPERCENT_SOLO * Global.Powerup_PlayersNumAdvantage;
			Global.GTemp[10] = Global.POWERUP_DAMAGEPERCENT_SOLO * Global.Powerup_PlayersNumAdvantage;
		End;
		Set Max Health(All Players(Team Of(Event Player)), 100 + Global.GTemp[9]);
		Set Damage Dealt(All Players(Team Of(Event Player)), 100 + Global.GTemp[10]);
		Global.Powerup_HUDText = Custom String("\n+{0}% HP {1}", Global.GTemp[9], Custom String("+{0}% Damage",
			Global.GTemp[10]));
		Global.Powerup_EmpoweredTeam = Team Of(Event Player);
		Log To Inspector(Custom String("powerup x{1} {0} (evt:{2})", Team Of(Event Player), Global.Powerup_PlayersNumAdvantage,
			Event Player));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("  {0} powered up!", Team Of(Event Player)));
	}
}

rule("1v1 Time Limit: Prevent long 1v1s when others waiting")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The code of this entire \"1v1 Time Limit\" ruleset might feel overengineered, several reasons for it: dummy bots polluting player counts, match time being partially immutable in Elimination, not spawned players being counted as alive"
		Global.TimeLimit1v1_Triggers[3] == True;
	}

	actions
	{
		Abort If(Count Of(Global.RealAlivePlayers) != 2);
		Abort If(Count Of(Global.RealPlayers) - Count Of(Global.RealAlivePlayers) == 0);
		Global.GTemp[3] = 40;
		"Dont bother with countdown if match near ending (XXX: match time is 0 for a few seconds at the start of round)"
		Abort If(Match Time <= Global.GTemp[3] && Match Time != 0);
		Log To Inspector(Custom String("1v1 time limit countdown start"));
		While(Global.GTemp[3]);
			Abort If(!Global.IsRoundActive);
			"First 10 seconds we just count down silently and allow to cancel if someone is revived"
			If(Global.GTemp[3] > 30);
				Abort If(Count Of(Global.RealPlayers) - Count Of(Global.RealAlivePlayers) == 0);
			End;
			If(Global.GTemp[3] == 30);
				"This line is just to hide default countdown UI"
				Set Match Time(120);
				Create HUD Text(All Players(All Teams), Null, Null, Custom String("Round ends in: {0}", Global.GTemp[3]), Top, 1, Color(
					White), Color(White), Global.GTemp[3] > 10 ? Color(White) : Custom Color(250, 55, 65, 255), String and Color,
					Default Visibility);
				Global.GTextIDS[0] = Last Text ID;
			End;
			Wait Until(!Global.IsRoundActive, 1);
			Global.GTemp[3] -= 1;
		End;
		Destroy HUD Text(Global.GTextIDS[0]);
		Abort If(!Global.IsRoundActive);
		Log To Inspector(Custom String("1v1 time limit reached"));
		Abort If(Global.DBG);
		Declare Round Draw;
	}
}

rule("1v1 Time Limit: Prevent long 1v1s when others waiting (tracking and triggers)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"This entire rule needs to be separate from main rule. Even when merged which is logically seems easily doable it then stops detecting triggers inequalities *sometimes*."
		Global.IsRoundActive == True;
		(Global.TimeLimit1v1_Triggers[0] != Number Of Living Players(All Teams) || Global.TimeLimit1v1_Triggers[1] != Number Of Players(
			Team 1) || Global.TimeLimit1v1_Triggers[2] != Number Of Players(Team 2)) == True;
	}

	actions
	{
		"This trigger sets the main rule in motion, we reset it here to toggle on in a moment"
		Global.TimeLimit1v1_Triggers[3] = False;
		"Wait to ensure triggers update on next frame and not the same one as when change was detected (otherwise rule can get stuck in \"true\" state forever)"
		Wait(0.250, Ignore Condition);
		"These triggers track alive and total players so when anything like that changes we catch it in this rule"
		Global.TimeLimit1v1_Triggers[0] = Number Of Living Players(All Teams);
		Global.TimeLimit1v1_Triggers[1] = Number Of Players(Team 1);
		Global.TimeLimit1v1_Triggers[2] = Number Of Players(Team 2);
		Call Subroutine(FindRealPlayers);
		Abort If(!Global.IsRoundActive);
		Global.TimeLimit1v1_Triggers[3] = True;
	}
}

rule("Lobby Balance: Minimize team size difference and shuffle players when one team dominates")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.LobbyBalance_Paused != True;
		Global.DBG != True;
		Global.IsRoundActive != True;
		Global.LobbyBalance_VictorTeam != -1;
	}

	actions
	{
		"Wait before all utility bots are destroyed"
		Wait Until(!Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Slot Of(Current Array Element)
			> 3)), 2);
		"Wait a bit so the player swap feels less jarring to the players being moved"
		Wait(0.500, Ignore Condition);
		">>>>>>>>>>>>>>>>>> STEP 1: Move newbies into new random team <<<<<<<<<<<<<<<<<<"
		Global.GTemp[13] = False;
		"XXX: Have to be very careful in this rule, moving players doesn't immediately update lobby data. We keep track of things ourselves and only one step is allowed to actually move players."
		Global.GTemp[0] = Number Of Players(Team 1) - Number Of Players(Team 2);
		"For a single new joiner or odd amount of joiners, lobby is biased towards Team 1. We remove bias by randomly moving a single new joiner to Team 2."
		If(Entity Exists(Global.LobbyBalance_Team1Newbie) && Global.GTemp[0] >= 1 && Random Integer(0, 1));
			Log To Inspector(Custom String("randomly moving \"{0}\" to {1}", Global.LobbyBalance_Team1Newbie, Team 2));
			Global.GTemp[13] = True;
			Global.GTemp[0] -= 1;
			Global.DBGMovedPlayersNum += 1;
			Move Player to Team(Global.LobbyBalance_Team1Newbie, Empty Array, -1);
			Move Player to Team(Global.LobbyBalance_Team1Newbie, Team 2, -1);
		End;
		Global.LobbyBalance_Team1Newbie = Null;
		">>>>>>>>>>>>>>>>>> STEP 2: Ensure minimal size difference <<<<<<<<<<<<<<<<<<"
		If(Workshop Setting Toggle(Custom String("1. Lobby Balance"), Custom String("Balance team sizes at round end"), True, 0)
			&& !Global.GTemp[13]);
			Global.GTemp[11] = Null;
			If(Global.GTemp[0] > 1);
				Global.GTemp[11] = Last Of(All Players(Team 1));
				Global.GTemp[0] -= 1;
			Else If(Global.GTemp[0] < -1);
				Global.GTemp[11] = Last Of(All Players(Team 2));
				Global.GTemp[0] += 1;
			End;
			"NOTE: In case of teams being 1:4 players it will take 2 rounds to balance"
			If(Global.GTemp[11]);
				Global.GTemp[13] = True;
				Global.GTemp[12] = Opposite Team Of(Team Of(Global.GTemp[11]));
				Log To Inspector(Custom String("moving \"{0}\" to {1}", Global.GTemp[11], Global.GTemp[12]));
				Global.DBGMovedPlayersNum += 1;
				Move Player to Team(Global.GTemp[11], Empty Array, -1);
				Move Player to Team(Global.GTemp[11], Global.GTemp[12], -1);
			End;
		End;
		">>>>>>>>>>>>>>>>>> STEP 3: Swap players when one team dominates <<<<<<<<<<<<<<<<<<"
		Global.GTemp[6] = Workshop Setting Integer(Custom String("1. Lobby Balance"), Custom String(
			"Swap random players when one team wins this many rounds in a row (0 to disable)"), 4, 0, 10, 1);
		If(Number Of Players(Team 1) == 1 || Number Of Players(Team 2) == 1);
			Global.GTemp[6] = Workshop Setting Integer(Custom String("1. Lobby Balance"), Custom String(
				"Swap random players when one team wins this many rounds in a row in 2v1 (0 to disable)"), 3, 0, 10, 1);
		End;
		Abort If(!Global.GTemp[6]);
		If(Global.GTemp[0] >= 1);
			Global.GTemp[7] = Custom String(">{0}", Global.LobbyBalance_VictorTeam);
		Else If(Global.GTemp[0] <= -1);
			Global.GTemp[7] = Custom String("<{0}", Global.LobbyBalance_VictorTeam);
		Else;
			Global.GTemp[7] = Custom String("={0}", Global.LobbyBalance_VictorTeam);
		End;
		If(Global.GTemp[7] != Global.LobbyBalance_WinStreakID);
			Global.LobbyBalance_WinStreak = 0;
		End;
		Global.LobbyBalance_WinStreakID = Global.GTemp[7];
		"Abort if: draw"
		Abort If(!Global.LobbyBalance_VictorTeam);
		Global.LobbyBalance_WinStreak += 1;
		"Abort if: 1v1"
		Abort If(Number Of Players(All Teams) <= 2);
		"Abort if: low streak"
		Abort If(Global.LobbyBalance_WinStreak < Global.GTemp[6]);
		"Abort if: we already moved someone on other steps (NOTE: If this does not abort then we did not move anything prior and the lobby data can be relied on)"
		Abort If(Global.GTemp[13]);
		"Abort if: smaller team dominating"
		Abort If(Number Of Players(Global.LobbyBalance_VictorTeam) < Number Of Players(Opposite Team Of(Global.LobbyBalance_VictorTeam)));
		Global.LobbyBalance_WinStreak = 0;
		Global.GTemp[7] = Null;
		Global.GTemp[8] = Null;
		Global.DBGMovedPlayersNum += 1;
		Global.GTemp[7] = Random Value In Array(All Players(Global.LobbyBalance_VictorTeam));
		If(Number Of Players(Global.LobbyBalance_VictorTeam) == Number Of Players(Opposite Team Of(Global.LobbyBalance_VictorTeam)));
			Global.DBGMovedPlayersNum += 1;
			Global.GTemp[8] = Random Value In Array(All Players(Opposite Team Of(Global.LobbyBalance_VictorTeam)));
		End;
		Log To Inspector(Custom String("swapping teams for \"{0}\" and \"{1}\"", Global.GTemp[7], Global.GTemp[8]));
		Move Player to Team(Global.GTemp[7], Empty Array, -1);
		Move Player to Team(Global.GTemp[8], Empty Array, -1);
		Move Player to Team(Global.GTemp[7], Opposite Team Of(Global.LobbyBalance_VictorTeam), -1);
		Move Player to Team(Global.GTemp[8], Global.LobbyBalance_VictorTeam, -1);
		Start Rule(LobbyBalance_Notify, Do Nothing);
	}
}

rule("Lobby Balance: Sub: Show notification")
{
	event
	{
		Subroutine;
		LobbyBalance_Notify;
	}

	actions
	{
		"The chasing serves for a fade in / out effect. Not exactly necessary, unsure why I bothered but w/e."
		Global.ChaserVar1 = 0;
		Wait(0.800, Ignore Condition);
		Chase Global Variable Over Time(ChaserVar1, 190, 0.200, None);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("\n\n\n\n\nPlayers reordered"), Top, 0, Null, Null,
			Custom Color(255, 255, 255, Global.ChaserVar1), Color, Visible Always);
		Global.GTextIDS[1] = Last Text ID;
		Wait Until(Global.ChaserVar1 == 190, 1);
		Stop Chasing Global Variable(ChaserVar1);
		Wait(3, Ignore Condition);
		Chase Global Variable Over Time(ChaserVar1, 0, 0.300, None);
		Wait Until(Global.ChaserVar1 == 0, 1);
		Stop Chasing Global Variable(ChaserVar1);
		Destroy HUD Text(Global.GTextIDS[1]);
	}
}

rule("Lobby Balance: Allow to pause / unpause")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Global.LobbyBalance_Paused = !Global.LobbyBalance_Paused;
		If(Global.LobbyBalance_Paused);
			Small Message(Event Player, Custom String("  Lobby Balancing: Paused"));
		Else;
			Small Message(Event Player, Custom String("  Lobby Balancing: Resumed"));
		End;
	}
}

rule("Lobby Balance: Keep track of new players joining")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Workshop Setting Toggle(Custom String("1. Lobby Balance"), Custom String(
			"Put new players in random team at round end (when lobby becomes imbalanced)"), True, 2) == True;
		"Don't bother tracking newbies inbetween rounds, too messy too account for that"
		Global.IsRoundActive == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Global.LobbyBalance_Team1Newbie = Event Player;
	}
}

rule("Sub: Find all real players")
{
	event
	{
		Subroutine;
		FindRealPlayers;
	}

	actions
	{
		"NOTE: For debugging purposes we treat dummies in player slots (0-3) as real players"
		Global.RealPlayers = Filtered Array(All Players(All Teams), !(Is Dummy Bot(Current Array Element) && Slot Of(Current Array Element)
			> 3));
		"This also excludes not spawned players. Joined but not spawned players count as alive which is usually undesirable."
		Global.RealAlivePlayers = Filtered Array(Global.RealPlayers, Is Alive(Current Array Element) && Has Spawned(
			Current Array Element));
	}
}

disabled rule("Tank Heroes: Increase knockback received")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"XXX: Disabled for now. Rule not needed as of most recent patch (September 17, 2024, tank knockback resist 25%)."
		Global.IsRoundStart == True;
		Array Contains(All Tank Heroes, Hero Of(Event Player)) == True;
	}

	actions
	{
		"Desired resist (original Overwatch 2 release value of 30%)"
		Global.GTemp[14] = 30;
		"Hardcoded resist of most recent patch (July 9, 2024)"
		Global.GTemp[15] = 40;
		Set Knockback Received(Event Player, 100 * ((100 - Global.GTemp[14]) / (100 - Global.GTemp[15])));
	}
}

rule("Hero: Ana (self ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_ANA_SELF_ULT == True;
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is Dummy Bot(Event Player) == False;
		(Hero Of(Event Player) == Hero(Ana) || Hero Being Duplicated(Event Player) == Hero(Ana)) == True;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(Event Player, Stunned)) == False;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 0);
		Create Dummy Bot(Hero(Ana), Team Of(Event Player), 10, Vector(0, 0, 0), Vector(0, 0, 0));
		Set Invisible(Players In Slot(10, Team Of(Event Player)), All);
		Start Forcing Dummy Bot Name(Players In Slot(10, Team Of(Event Player)), Custom String("Ana Apparition"));
		Start Forcing Player Position(Players In Slot(10, Team Of(Event Player)), Position Of(Event Player) + Vector(0, 5, 1), False);
		Set Status(Players In Slot(10, Team Of(Event Player)), Null, Phased Out, 9999);
		Start Facing(Players In Slot(10, Team Of(Event Player)), Direction Towards(Players In Slot(10, Team Of(Event Player)),
			Event Player), 1000, To World, Direction and Turn Rate);
		Wait(0.400, Ignore Condition);
		Press Button(Players In Slot(10, Team Of(Event Player)), Button(Ultimate));
		"Support line for when Echo ults as Ana"
		Event Player.Echo_DupeUlted = True;
		Wait Until((Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) != True, 9);
		Destroy Dummy Bot(Team Of(Event Player), 10);
	}
}

rule("Hero: Hammond (icicle grapple - icicle spawning)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_HAMMOND_ICICLE_GRAPPLE == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.Hammond_GrappleIsOn == False;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(Event Player, Stunned)) == False;
	}

	actions
	{
		"Position of where a fake icicle should be created (what hammond is looking at)."
		Event Player.Hammond_IciclePos = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 13, Null, Null, True);
		"Prevent underground icicle"
		If(Y Component Of(Event Player.Hammond_IciclePos) < 0.700);
			Event Player.Hammond_IciclePos = Vector(X Component Of(Event Player.Hammond_IciclePos), 0.700, Z Component Of(
				Event Player.Hammond_IciclePos));
		End;
		Create Dummy Bot(Hero(Mei), Team Of(Event Player), 11, Event Player.Hammond_IciclePos - Vector(0, 0.300, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(11, Team Of(Event Player)), Custom String("Icicle"));
		Start Forcing Player Position(Players In Slot(11, Team Of(Event Player)), Position Of(Players In Slot(11, Team Of(Event Player))),
			True);
		Set Invisible(Players In Slot(11, Team Of(Event Player)), All);
		Wait(0.065, Ignore Condition);
		Press Button(Players In Slot(11, Team Of(Event Player)), Button(Ability 1));
		Wait(1, Ignore Condition);
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)), 3);
		Destroy Dummy Bot(Team Of(Event Player), 11);
	}
}

rule("Hero: Hammond (icicle grapple - when grapple disabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_HAMMOND_ICICLE_GRAPPLE == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Global.IsRoundActive == True;
		(Absolute Value(X Component Of(Position Of(Event Player))) > 19.700 || Absolute Value(Z Component Of(Position Of(Event Player)))
			> 19.700 || Entity Exists(Players In Slot(11, Team Of(Event Player)))) == False;
	}

	actions
	{
		Event Player.Hammond_GrappleIsOn = False;
		Disallow Button(Event Player, Button(Secondary Fire));
	}
}

rule("Hero: Hammond (icicle grapple - when grapple enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_HAMMOND_ICICLE_GRAPPLE == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Global.IsRoundActive == True;
		(Absolute Value(X Component Of(Position Of(Event Player))) > 19.700 || Absolute Value(Z Component Of(Position Of(Event Player)))
			> 19.700 || Entity Exists(Players In Slot(11, Team Of(Event Player)))) == True;
	}

	actions
	{
		"If icicle was created"
		If(Entity Exists(Players In Slot(11, Team Of(Event Player))));
			Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.Hammond_IciclePos), 10000, To World,
				Direction and Turn Rate);
			"Allow some time for focus to snap onto icicle"
			Wait(0.170, Ignore Condition);
			Event Player.Hammond_GrappleIsOn = True;
			Allow Button(Event Player, Button(Secondary Fire));
			"Resetting ability triggers grapple to fire again when held"
			Set Secondary Fire Enabled(Event Player, False);
			Set Secondary Fire Enabled(Event Player, True);
			Stop Facing(Event Player);
		"If simply outside of island range"
		Else;
			Event Player.Hammond_GrappleIsOn = True;
			Allow Button(Event Player, Button(Secondary Fire));
		End;
	}
}

disabled rule("Hero: Hammond (piledriver buff)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Simple buffed piledriver rule, enable if empowered piledriver starts being an issue and need to be turned off"
		Global.FEATURE_HAMMOND_BUFF_PILEDRIVER == True;
		Ability Cooldown(Event Player, Button(Crouch)) > 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
	}

	actions
	{
		Start Damage Modification(All Players(All Teams), Event Player, 215, Receivers Damagers and Damage Percent);
		Event Player.PTemp[4] = Last Damage Modification ID;
		Set Knockback Dealt(Event Player, 115);
		Wait Until(Vertical Speed Of(Event Player) == 0, 2);
		Wait(0.250, Ignore Condition);
		Set Knockback Dealt(Event Player, 100);
		Stop Damage Modification(Event Player.PTemp[4]);
	}
}

rule("Hero: Hammond (empowered piledriver)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"It's a bit overkill in terms of implementation and effects. Mostly just added for fun. Might cause load issues or stray bugs."
		Global.FEATURE_HAMMOND_BUFF_PILEDRIVER == True;
		Ability Cooldown(Event Player, Button(Crouch)) > 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
	}

	actions
	{
		">>>>>>>>>>>>>>>>>> SETUP, CALC POWERUP <<<<<<<<<<<<<<<<<<"
		Event Player.ChaserVar1 = 1;
		Event Player.ChaserVar2 = 1;
		"Estimate as to where the ball shall land"
		Event Player.PTemp[8] = Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(Position Of(Event Player))) + Vector(
			X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))) * 5;
		"Current distance from landing"
		Event Player.PTemp[9] = Distance Between(Event Player.PTemp[8], Position Of(Event Player));
		"Distance from landing into radius multiplier (+1x size every 13 meters, maximum of 3x)"
		Event Player.PTemp[10] = 1 + Min(Event Player.PTemp[9] / 13, 2);
		"Static damage and knockback powerups of inner ring"
		Start Damage Modification(All Players(All Teams), Event Player, 215, Receivers Damagers and Damage Percent);
		Event Player.PTemp[4] = Last Damage Modification ID;
		Set Knockback Dealt(Event Player, 115);
		Start Scaling Player(Event Player, Event Player.ChaserVar1, True);
		">>>>>>>>>>>>>>>>>> APPLY VISUAL EFFECTS <<<<<<<<<<<<<<<<<<"
		Create Effect(Event Player, Ring, Color(Gray), Event Player.PTemp[8], 8, Position and Radius);
		Event Player.PTemp[6] = Last Created Entity;
		Create Effect(Event Player, Ring, Color(White), Event Player.PTemp[8], 8 * Event Player.ChaserVar2, Position and Radius);
		Event Player.PTemp[7] = Last Created Entity;
		"Scale outer ring"
		Chase Player Variable Over Time(Event Player, ChaserVar2, Event Player.PTemp[10], 0.500, None);
		"Wait untill the rollout animation completes"
		Wait(0.100, Ignore Condition);
		Wait Until(Speed Of In Direction(Event Player, Down) > 0, 1);
		"Scale player (exaggerate final size slightly, devide distance by 150 meters for the animation speed)"
		Chase Player Variable Over Time(Event Player, ChaserVar1, Event Player.PTemp[10] * 1.300, Event Player.PTemp[9] / 150, None);
		Wait Until(Vertical Speed Of(Event Player) == 0, 1);
		">>>>>>>>>>>>>>>>>> LANDING, IMMEDIATE CLEANUP <<<<<<<<<<<<<<<<<<"
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Stop Chasing Player Variable(Event Player, ChaserVar2);
		Destroy Effect(Event Player.PTemp[6]);
		Destroy Effect(Event Player.PTemp[7]);
		"Scale player back down (better idea was to scale in two instant steps: half to original then to original, split by .1s waits, looks way better but too janky for hammond)"
		Chase Player Variable Over Time(Event Player, ChaserVar1, 1, 0.130, None);
		">>>>>>>>>>>>>>>>>> FIND VICTIMS AND FLAG THEM TO BE HARMED <<<<<<<<<<<<<<<<<<"
		Call Subroutine(FindRealPlayers);
		Event Player.PTempArray1 = Filtered Array(Global.RealAlivePlayers, Team Of(Current Array Element) != Team Of(Event Player));
		Event Player.PTemp[11] = 0;
		While(Event Player.PTemp[11] < Count Of(Event Player.PTempArray1));
			Event Player.PTemp[12] = Event Player.PTempArray1[Event Player.PTemp[11]];
			Event Player.PTemp[11] += 1;
			Event Player.PTemp[13] = Distance Between(Position Of(Event Player.PTemp[12]), Event Player);
			Skip If(Event Player.PTemp[13] < 8 * Event Player.PTemp[10] && !Has Status(Event Player.PTemp[12], Phased Out) && !Has Status(
				Event Player.PTemp[12], Invincible), 1);
			Continue;
			Skip If(Event Player.PTemp[12].Hammond_PiledriverHarmFlag != -1, 1);
			Continue;
			"Barrier detection (BUG: can be blind to barriers which  have an enemy stand in the middle of it and that enemy is also between victim and ball)"
			Event Player.PTemp[14] = Position Of(Event Player) + Vector(0, 1, 0);
			Event Player.PTemp[15] = Position Of(Event Player.PTemp[12]) + Vector(0, 1, 0);
			Event Player.PTemp[15] += Direction Towards(Position Of(Event Player), Event Player.PTemp[12]);
			Event Player.PTemp[16] = 0;
			While(Event Player.PTemp[16] < 3);
				"Cast ray from attacker to victim"
				Event Player.PTemp[17] = Ray Cast Hit Player(Event Player.PTemp[14], Event Player.PTemp[15], Event Player.PTempArray1, Null, True);
				Event Player.PTemp[20] = Ray Cast Hit Position(Event Player.PTemp[14], Event Player.PTemp[15], Event Player.PTempArray1, Null,
					True);
				"We reached player or his destination unobstructed"
				If(Event Player.PTemp[17] == Event Player.PTemp[12] || Event Player.PTemp[15] == Event Player.PTemp[20]);
					Event Player.PTemp[12].Hammond_PiledriverHarmFlag = Event Player;
					Break;
				"We reached non player obstacle"
				Else If(!Event Player.PTemp[17]);
					Break;
				End;
				"We detected another player in the way, reverse cast the ray to find that player opposite side and move our ray origin there"
				Event Player.PTemp[18] = Ray Cast Hit Player(Event Player.PTemp[15], Event Player.PTemp[14], Event Player.PTemp[17], Null, False);
				Event Player.PTemp[14] = Ray Cast Hit Position(Event Player.PTemp[15], Event Player.PTemp[14], Event Player.PTemp[17], Null,
					False);
				Event Player.PTemp[14] += Normalize(Event Player.PTemp[14]) * 0.010;
				"If we hit non player obstacle on the way from target to back of collided player means that obstacle also protects victim"
				If(!Event Player.PTemp[18]);
					Break;
				End;
				Event Player.PTemp[16] += 1;
			End;
		End;
		">>>>>>>>>>>>>>>>>> FINAL CLEANUP <<<<<<<<<<<<<<<<<<"
		Skip(0);
		"Short wait to ensure all damages taken place"
		Wait(0.250, Ignore Condition);
		Set Knockback Dealt(Event Player, 100);
		Stop Damage Modification(Event Player.PTemp[4]);
		"Wait until we scaled the player back down"
		Wait Until(Event Player.ChaserVar1 == 1, 1);
		Stop Chasing Player Variable(Event Player, ChaserVar2);
		Stop Scaling Player(Event Player);
	}
}

rule("Hero: Hammond (empowered piledriver - harm bonus victims)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_HAMMOND_BUFF_PILEDRIVER == True;
		Event Player.Hammond_PiledriverHarmFlag != Null;
		Event Player.Hammond_PiledriverHarmFlag != -1;
	}

	actions
	{
		Wait Until(Event Player.Hammond_PiledriverHarmFlag == -1, 0.100);
		Abort If(Event Player.Hammond_PiledriverHarmFlag == -1);
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		Wait(0.016, Ignore Condition);
		Stop Forcing Player Position(Event Player);
		Damage(Event Player, Event Player.Hammond_PiledriverHarmFlag, 20);
		Play Effect(Event Player, Explosion Sound, Color(White), Event Player, 70);
		Apply Impulse(Event Player, Up + 0.650 * Direction Towards(Position Of(Event Player), Event Player.Hammond_PiledriverHarmFlag),
			Array Contains(All Tank Heroes, Hero Of(Event Player)) ? 11 : 13.500, To World, Cancel Contrary Motion);
		Set Move Speed(Event Player, 20);
		Wait(0.500, Ignore Condition);
		Event Player.PTemp[19] = 1;
		While(Event Player.PTemp[19] < 5);
			If(Event Player.PTemp[19] > 1);
				Wait(0.100, Ignore Condition);
			End;
			Set Move Speed(Event Player, 20 + 20 * Event Player.PTemp[19]);
			Event Player.PTemp[19] += 1;
		End;
		Event Player.Hammond_PiledriverHarmFlag = Null;
	}
}

rule("Hero: Hammond (empowered piledriver - prevent double damage)")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_HAMMOND_BUFF_PILEDRIVER == True;
		Event Ability == Button(Crouch);
		Hero Of(Attacker) == Hero(Wrecking Ball);
	}

	actions
	{
		Event Player.Hammond_PiledriverHarmFlag = -1;
		Wait(0.300, Ignore Condition);
		Event Player.Hammond_PiledriverHarmFlag = Null;
	}
}

rule("Hero: Hammond (empowered piledriver - hovering guide circle)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_HAMMOND_BUFF_PILEDRIVER == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Y Component Of(Position Of(Event Player)) > 2;
		Ability Cooldown(Event Player, Button(Crouch)) == 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
	}

	actions
	{
		Create Effect(Event Player, Ring, Color(Gray), Update Every Frame(Vector(X Component Of(Position Of(Event Player)), 0,
			Z Component Of(Position Of(Event Player))) + Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(
			Facing Direction Of(Event Player))) * 5), 8, Position and Radius);
		Event Player.PTemp[5] = Last Created Entity;
		Wait Until(Y Component Of(Position Of(Event Player)) <= 2 || Ability Cooldown(Event Player, Button(Crouch)) > 0 || !Is Alive(
			Event Player) || !Entity Exists(Event Player) || !Global.IsRoundActive || (Hero Of(Event Player) == Hero(Wrecking Ball)
			|| Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) != True, 9999);
		Destroy Effect(Event Player.PTemp[5]);
	}
}

rule("Hero: Junkrat (mid-air ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.FEATURE_JUNK_AIR_ULT == True;
		Is Button Held(Event Player, Button(Ultimate)) == True;
		(Hero Of(Event Player) == Hero(Junkrat) || Hero Being Duplicated(Event Player) == Hero(Junkrat)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(Event Player, Stunned)) == False;
	}

	actions
	{
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		Create Dummy Bot(Hero(Mei), Team Of(Event Player), 8, Position Of(Event Player) - Vector(0, 2.600, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(8, Team Of(Event Player)), Custom String("Icicle"));
		Set Invisible(Players In Slot(8, Team Of(Event Player)), All);
		Start Forcing Player Position(Players In Slot(8, Team Of(Event Player)), Position Of(Players In Slot(8, Team Of(Event Player))),
			False);
		Wait(0.065, Ignore Condition);
		Press Button(Players In Slot(8, Team Of(Event Player)), Button(Ability 1));
		Stop Forcing Player Position(Event Player);
		Wait Until(!Is In Air(Event Player), 1);
		Press Button(Event Player, Button(Ultimate));
		Destroy Dummy Bot(Team Of(Event Player), 8);
	}
}

rule("Hero: Junkrat (faster / smaller tire)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		(Hero Of(Event Player) == Hero(Junkrat) || Hero Being Duplicated(Event Player) == Hero(Junkrat)) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Set Move Speed(Event Player, 120);
		Start Scaling Player(Event Player, 0.750, True);
		Wait Until(!Is Using Ultimate(Event Player), 10);
		Set Move Speed(Event Player, 100);
		Stop Scaling Player(Event Player);
	}
}

rule("Hero: Junkrat (infinite mines outside the island)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Junkrat) || Hero Being Duplicated(Event Player) == Hero(Junkrat)) == True;
		Global.IsRoundActive == True;
		Y Component Of(Position Of(Event Player)) < -1;
		Ability Charge(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Set Ability Charge(Event Player, Button(Ability 1), 1);
	}
}

rule("Hero: Junkrat + Bastion (reduce gravity when ulting outside the island)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Global.IsRoundActive == True;
		"Won't bother letting Echo clone use this rule"
		(Hero Of(Event Player) == Hero(Junkrat) || Hero Of(Event Player) == Hero(Bastion)) == True;
		(Absolute Value(X Component Of(Position Of(Event Player))) > 20 || Absolute Value(Z Component Of(Position Of(Event Player))) > 20)
			== True;
	}

	actions
	{
		If(Hero Of(Event Player) != Hero(Junkrat));
			Set Gravity(Event Player, 35);
			Apply Impulse(Event Player, Vector(0, 1, 0), 1, To World, Cancel Contrary Motion);
			Wait Until(!Is Using Ultimate(Event Player), 10);
			Set Gravity(Event Player, 100);
		Else;
			Wait(1.5, Abort When False);
			"Simulate gravity for Junkrat. `Set Gravity` and `Start Accel..` affects his tire which is bad."
			While(True);
				Wait(.1, Abort When False);
				If(Speed Of In Direction(Event Player, Vector(0, -1, 0)) > 0);
					"Magick value that looks ~like 35% gravity. Found by trial and error."
					Apply Impulse(Event Player, Vector(0, 1, 0), 1.48, To World, Incorporate Contrary Motion);
				End;
			End;
		End;
	}
}

rule("Hero: D.Va (start with an ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
	}

	actions
	{
		"NOTE: We are setting ult to 100% in the rules instead of settings because the setting makes her gain 100% ult every time she re-mechs."
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Hero: Anran (start with an ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Anran;
	}

	conditions
	{
		"True in first 3 seconds of match"
		Match Time == 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
	}

	actions
	{
		"NOTE: Same reason as D.Va. Anran gets ult on self-resurrect."
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Hero: Soldier 76 (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Soldier: 76;
	}

	conditions
	{
		Global.IsRoundActive == True;
		"This ensure this also triggers on resurrect"
		Is Alive(Event Player) == True;
	}

	actions
	{
		"Value is tweaked with respect to \"Pre-game ult generation\""
		Set Ultimate Charge(Event Player, 95);
	}
}

rule("Hero: McCree (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Cassidy;
	}

	conditions
	{
		Global.IsRoundActive == True;
		"This ensure this also triggers on resurrect"
		Is Alive(Event Player) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 98);
	}
}

rule("Hero: Roadhog (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Global.IsRoundActive == True;
		"This ensure this also triggers on resurrect"
		Is Alive(Event Player) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 80);
	}
}

rule("Hero: Lifeweaver (ult duration)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Event Player.ChaserVar1 = 100;
		Event Player.PTemp[0] = Eye Position(Event Player);
		Event Player.PTemp[1] = Eye Position(Event Player) + Facing Direction Of(Event Player) * 40;
		"Wait for tree to spawn"
		Wait(0.250, Ignore Condition);
		"Cast ray from recorded eye position to recorded position these eyes were looking at, find a tree hit by the ray, shift found position upwards by 1 and away from eyes by 2 to center into tree trunk"
		Event Player.PTemp[1] = Ray Cast Hit Position(Event Player.PTemp[0], Event Player.PTemp[1], Null, Null, True)
			+ Facing Direction Of(Event Player) * Vector(2, 0, 2) + Vector(0, 1, 0);
		disabled Create Effect(All Players(All Teams), Sphere, Color(Red), Event Player.PTemp[1], 1, None);
		Create Progress Bar In-World Text(All Players(Team Of(Event Player)), Event Player.ChaserVar1, Null, Event Player.PTemp[1], 0.750,
			Do Not Clip, Custom Color(255, 235, 130, 255), Null, Values, Default Visibility);
		Event Player.PTextIDS[0] = Last Text ID;
		Chase Player Variable Over Time(Event Player, ChaserVar1, 0, 5, None);
		Wait Until(Event Player.ChaserVar1 == 0, 15);
		Press Button(Event Player, Button(Ultimate));
		Destroy Progress Bar In-World Text(Event Player.PTextIDS[0]);
	}
}

rule("Hero: Lifeweaver (ult duration - cleanup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		"XXX: normally there seems to be no way to reliably detect tree being destroyed, as a hacky workaround we just check if weaver starts building ult again, meaning there is no tree active"
		Ultimate Charge Percent(Event Player) > 0;
		Event Player.ChaserVar1 != 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Destroy Progress Bar In-World Text(Event Player.PTextIDS[0]);
	}
}

rule("Hero: Winstor (limit barrier HP)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Global.IsRoundActive == True;
		(Hero Of(Event Player) == Hero(Winston) || Hero Being Duplicated(Event Player) == Hero(Winston)) == True;
	}

	actions
	{
		Event Player.PTemp[2] = Position Of(Event Player);
		"Atop the edge of shield border"
		Event Player.PTemp[3] = Position Of(Event Player) + Vector(0, 5.400, 0);
		"We create a dummy bot in the opposite team for it to own the projectile. Granting ownership to null or arbitrary opposite team member has side effects and incosistencies."
		Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Event Player)), 7, Vector(0, -2, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(7, Opposite Team Of(Team Of(Event Player))), Custom String("Apparition"));
		Set Invisible(Players In Slot(7, Opposite Team Of(Team Of(Event Player))), All);
		Wait(0.100, Ignore Condition);
		Create Projectile(Orb Projectile, Players In Slot(7, Opposite Team Of(Team Of(Event Player))), Event Player.PTemp[3],
			Direction Towards(Event Player.PTemp[3], Event Player.PTemp[2]), To World, Damage, Team Of(Event Player), 340, 0, 0,
			Bad Explosion, Explosion Sound, 0, 0.100, 0.200, 0, 0, 0);
		Wait(0.200, Ignore Condition);
		Destroy Dummy Bot(Opposite Team Of(Team Of(Event Player)), 7);
	}
}

rule("Hero: Echo (support others faux abilities)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Echo;
	}

	conditions
	{
		"Most of the support is added via hero specific rule conditions, this is currently just setup for later cleanup"
		Is Duplicating(Event Player) == True;
	}

	actions
	{
		Event Player.Echo_JustDuplicated = Hero Being Duplicated(Event Player);
		Event Player.Echo_DupeUlted = Null;
		Wait Until(Is Using Ultimate(Event Player) && Is Duplicating(Event Player), 9999);
		Event Player.Echo_DupeUlted = True;
	}
}

rule("Hero: Echo (support others faux abilities - cleanup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Echo;
	}

	conditions
	{
		Is Duplicating(Event Player) != True;
		Event Player.Echo_JustDuplicated != Null;
	}

	actions
	{
		Allow Button(Event Player, Button(Secondary Fire));
		If(Event Player.Echo_JustDuplicated == Hero(Ana) && Event Player.Echo_DupeUlted);
			Destroy Dummy Bot(Team Of(Event Player), 10);
		End;
		Event Player.Echo_JustDuplicated = Null;
	}
}

rule("Hero: Widowmaker (armor on ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		(Hero Of(Event Player) == Hero(Widowmaker) || Hero Being Duplicated(Event Player) == Hero(Widowmaker)) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Armor, 100, False, True);
	}
}

rule("Hero: Hanzo (armor on ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		(Hero Of(Event Player) == Hero(Hanzo) || Hero Being Duplicated(Event Player) == Hero(Hanzo)) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Armor, 50, False, True);
		Add Health Pool To Player(Event Player, Armor, 500, False, True);
		Event Player.PTemp[21] = Last Created Health Pool;
		Wait Until(!Is Using Ultimate(Event Player), 3);
		Remove Health Pool From Player(Event Player.PTemp[21]);
	}
}

rule("Hero: Zarya (no self damage + secondary refund)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Zarya) || Hero Being Duplicated(Event Player) == Hero(Zarya)) == True;
		Global.IsRoundActive == True;
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Start Damage Modification(Event Player, Event Player, 0, None);
		Set Ammo(Event Player, 0, Ammo(Event Player, 0) + 25);
	}
}

rule("Hero: Zarya (big self knockback)")
{
	event
	{
		Player Dealt Knockback;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Zarya) || Hero Being Duplicated(Event Player) == Hero(Zarya)) == True;
		Victim == Event Player;
	}

	actions
	{
		Apply Impulse(Event Player, Event Direction, 22, To World, Incorporate Contrary Motion);
	}
}

disabled rule("DBG: Main toggle")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DBG = True;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("DBG {0}", Global.DBGMsg), Right, 0, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("DBG: Enable hero select")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DBGAllowHeroSelect = 8;
	}
}

rule("DBG: Server load view toggler")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		If(Array Contains(Global.ServerLoadVisibleTo, Custom String("{0}", Event Player)));
			Global.ServerLoadVisibleTo = Remove From Array(Global.ServerLoadVisibleTo, Custom String("{0}", Event Player));
		Else;
			Global.ServerLoadVisibleTo = Append To Array(Global.ServerLoadVisibleTo, Custom String("{0}", Event Player));
	}
}

rule("DBG: Persistent dummy bots")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Total Time Elapsed < 3;
		Event Player == Host Player;
	}

	actions
	{
		Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 0, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 1, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 2, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 3, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 1, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 2, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 3, Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

rule("DBG: Persistent bot shooting toggler")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Event Player == Host Player;
	}

	actions
	{
		Global.DBGBotShooting = !Global.DBGBotShooting;
	}
}

rule("DBG: Persistent bot aim and shoot")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBGBotShooting == True;
		Slot Of(Event Player) == 0;
		Is Dummy Bot(Event Player) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Start Facing(Event Player, Direction From Angles(90, 3), 100, To Player, None);
		While(True);
			Wait(2, Ignore Condition);
			Press Button(Event Player, Button(Primary Fire));
			Abort If(!Global.DBGBotShooting);
		End;
	}
}

rule("DBG: Melee actions (for dev drafts)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("  Melee DBG"));
	}
}

rule("DBG: Toggle spawn chance for in-development heroes")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		If(Global.DBGIndevHeroes == Null);
			Global.DBGIndevHeroes = Array(Hero(Anran), Hero(Domina), Hero(Jetpack Cat), Hero(Mizuki), Hero(Emre));
			Small Message(All Players(All Teams), Custom String("  Indev Heroes +Spawn: ON"));
		Else;
			Global.DBGIndevHeroes = Null;
			Small Message(All Players(All Teams), Custom String("  Indev Heroes +Spawn: OFF"));
	}
}

rule("DBG: Bump spawn chance for in-development heroes")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBGIndevHeroes != Null;
		Global.IsRoundActive == True;
		Match Time == 0;
	}

	actions
	{
		If(Count Of(Filtered Array(All Players(All Teams), Array Contains(Global.DBGIndevHeroes, Hero Of(Current Array Element)))) > 0);
			Log To Inspector(Custom String("Indev Heroes +Spawn: skipping, exists"));
		Else If(Random Real(0, 1) < .3);
			Global.GTemp[16] = Random Value In Array(All Players(All Teams));
			Log To Inspector(Custom String("Indev Heroes +Spawn: invoked on {0}", Global.GTemp[16]));
			Set Player Allowed Heroes(Global.GTemp[16], Random Value In Array(Global.DBGIndevHeroes));
			Wait(1, Ignore Condition);
			Reset Player Hero Availability(Global.GTemp[16]);
		Else;
			Log To Inspector(Custom String("Indev Heroes +Spawn: skipping, chance"));
		End;
	}
}
