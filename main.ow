settings
{
	main
	{
		Description: "All new OW2 heroes. Code: 48CYD\n- Hammond can grapple air.\n- Ana can self-ult.\n- Junk can ult mid-air.\n- D.Va doesn't get infinite nukes.\n- Anti-winston-trolling (limited airspace).\n- Lobby balancing.\n\nVer:1.6dev. All changes and info at:\ngithub.com/domuspopus/overwatch-4v4-all-heroes\nAlso at: workshop.codes/48CYD"
		Mode Name: "4v4 All Heroes (J-edit)"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: Paused
		Match Voice Chat: Enabled
		Max Team 1 Players: 4
		Max Team 2 Players: 4
		Return To Lobby: Never
		Swap Teams After Match: No
		Team Balancing: After A Game
	}

	modes
	{
		Elimination
		{
			enabled maps
			{
				Workshop Island 972777519512063901
				Workshop Island Night 972777519512064579
			}
		}

		General
		{
			Allow Hero Switching: Off
			Capture Objective Tiebreaker: Off
			Game Mode Start: Immediately
			Respawn As Random Hero: On
			Respawn Time Scalar: 0%
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 25%
			Spawn With Ultimate Ready: On
			Ultimate Generation: 200%
			Ultimate Generation - Combat: 130%

			Cassidy
			{
				Spawn With Ultimate Ready: Off
				Ultimate Generation - Combat Deadeye: 200%
				Ultimate Generation - Passive Deadeye: 10%
			}

			D.Va
			{
				Self Destruct Knockback Scalar: 200%
				Spawn With Ultimate Ready: Off
			}

			Junkrat
			{
				Concussion Mine Knockback Scalar: 120%
			}

			Lifeweaver
			{
				Petal Platform Health: 25%
				Tree of Life Health: 50%
			}

			Mercy
			{
				Health: 85%
				Resurrect Cooldown Time: 60%
			}

			Moira
			{
				Biotic Orb Cooldown Time: 45%
				Fade Cooldown Time: 35%
				Health: 85%
				Spawn With Ultimate Ready: Off
			}

			Orisa
			{
				Health: 62%
			}

			Reinhardt
			{
				Ultimate Generation - Passive Earthshatter: 400%
			}

			Roadhog
			{
				Health: 65%
				Spawn With Ultimate Ready: Off
			}

			Soldier: 76
			{
				Spawn With Ultimate Ready: Off
				Ultimate Duration: 50%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 10%
				Venom Mine Cooldown Time: 5%
			}

			Winston
			{
				Barrier Projector Cooldown Time: 35%
				Damage Dealt: 130%
				Health: 75%
			}

			Wrecking Ball
			{
				Grappling Claw Knockback Scalar: 115%
				Health: 65%
			}

			Zarya
			{
				Health: 65%
			}
		}
	}
}

variables
{
	global:
		0: IsRoundActive
		1: IsRoundStart
		2: TextIDS
		3: POWERUP_HPPERCENT
		4: POWERUP_DAMAGEPERCENT
		5: POWERUP_HPPERCENT_SOLO
		6: POWERUP_DAMAGEPERCENT_SOLO
		7: Powerup_PlayersNumAdvantage
		8: MAPBOUNDRY_VERTICAL
		9: MAPBOUNDRY_HORIZONTAL
		10: ServerLoadVisibleTo
		11: TimeLimit1v1_Triggers
		12: HUDTipColor
		13: Texts
		14: GTemp
		15: RealPlayers
		16: RealAlivePlayers
		17: GTempArray1
		18: Powerup_EmpoweredTeam
		19: LobbyBalance_LastSeenPlayers
		20: LobbyBalance_WinStreak
		21: LobbyBalance_WinStreakID
		22: LobbyBalance_VictorTeam
		23: Powerup_HUDText
		45: DBGMovedPlayersNum
		46: DBGRoundNum
		47: DBGAllowHeroSelect
		48: DBGMsg
		49: DBGBotShooting
		50: DBG

	player:
		0: TextIDS
		1: Hammond_GrappleIsOn
		2: Hammond_IciclePos
		3: ChaserVar1
		4: PTemp
		5: Echo_JustDuplicated
		6: Echo_DupeUlted
		7: ChaserVar2
		8: PTempArray1
		9: Hammond_PiledriverHarmFlag
}

subroutines
{
	0: FindRealPlayers
}

rule("PROJECT INFO")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Some important implementation details and notes are available at (click to show): https://github.com/domuspopus/overwatch-4v4-all-heroes/issues/20"
		Abort;
	}
}

rule("Base: Set global variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Auto-balancing variables. Bumps percentage of HP / damage of each player in smaller team."
		Global.POWERUP_HPPERCENT = 25;
		Global.POWERUP_DAMAGEPERCENT = 30;
		"Same as above but these will apply if team only has 1 player"
		Global.POWERUP_HPPERCENT_SOLO = 30;
		Global.POWERUP_DAMAGEPERCENT_SOLO = 50;
		"Map boundaries"
		Global.MAPBOUNDRY_VERTICAL = 25;
		Global.MAPBOUNDRY_HORIZONTAL = 45;
		"Misc"
		Disable Built-In Game Mode Announcer;
		Global.ServerLoadVisibleTo = Empty Array;
		Global.DBGRoundNum = 1;
		Wait Until(Host Player, 3);
		Global.LobbyBalance_LastSeenPlayers = Array(Host Player);
	}
}

rule("Base: Skip hero select, initiate round start variables")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		"Disable inspector in live game"
		If(!Global.DBG);
			Disable Inspector Recording;
		End;
		"Allow time to select in debug mode"
		If(Global.DBGAllowHeroSelect);
			Set Match Time(Global.DBGAllowHeroSelect);
			Wait(Global.DBGAllowHeroSelect, Ignore Condition);
		End;
		Global.Powerup_EmpoweredTeam = Null;
		"This skips the selection"
		Set Match Time(0);
		"Allow time for game to select hero for player and initiate round"
		Wait(0.250, Ignore Condition);
		Global.IsRoundActive = True;
		Global.IsRoundStart = True;
		Log To Inspector(Custom String(">>> round #{0} start", Match Round));
		Wait(0.250, Ignore Condition);
		Global.IsRoundStart = False;
	}
}

rule("Base: Round end (cleanup)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Between Rounds == True;
	}

	actions
	{
		Log To Inspector(Custom String(">>> round end"));
		If(Team Score(Team 1) > 0);
			Global.LobbyBalance_VictorTeam = Team 1;
		Else If(Team Score(Team 2) > 0);
			Global.LobbyBalance_VictorTeam = Team 2;
		Else;
			Global.LobbyBalance_VictorTeam = Null;
		End;
		Set Team Score(All Teams, 0);
		Global.IsRoundActive = False;
		Global.Powerup_PlayersNumAdvantage = 0;
		Global.DBGRoundNum += 1;
		Stop All Healing Modifications;
		Stop All Damage Modifications;
		Stop All Damage Over Time(All Players(All Teams));
		Stop Forcing Player Position(All Players(All Teams));
		Set Damage Dealt(All Players(All Teams), 100);
		Set Max Health(All Players(All Teams), 100);
		Allow Button(All Players(All Teams), Button(Secondary Fire));
		Destroy HUD Text(Global.TextIDS[0]);
		Set Knockback Dealt(All Players(All Teams), 100);
		Destroy All In-World Text;
		Destroy All Progress Bar In-World Text;
		Destroy All Effects;
		Stop Scaling Player(All Players(All Teams));
		Set Move Speed(All Players(All Teams), 100);
	}
}

rule("Base: Round end (cleanup - per player)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsRoundActive != True;
	}

	actions
	{
		"Destroy bots in slots 4-11, these are used for temporary dummy bots for faux abilities etc."
		If(Is Dummy Bot(Event Player) && Slot Of(Event Player) > 3);
			Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
		End;
		Destroy HUD Text(Event Player.TextIDS[0]);
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Stop Chasing Player Variable(Event Player, ChaserVar2);
		Event Player.Echo_JustDuplicated = Null;
		Event Player.Hammond_PiledriverHarmFlag = Null;
	}
}

rule("Base: Prevent heroes flying away")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Y Component Of(Position Of(Event Player)) > Global.MAPBOUNDRY_VERTICAL || Absolute Value(X Component Of(Position Of(
			Event Player))) > Global.MAPBOUNDRY_HORIZONTAL || Absolute Value(Z Component Of(Position Of(Event Player)))
			> Global.MAPBOUNDRY_HORIZONTAL) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Small Message(Event Player, Custom String(" {0} {1} {2}", Global.Texts[6], Icon String(Warning), Ability Icon String(Hero(Mercy),
			Button(Ability 1))));
		Set Status(Event Player, Null, Frozen, 2);
		Wait(1.900, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Base: Prevent premature game completion and skip victory screen")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBG != True;
		Is Waiting For Players != True;
		(Number Of Players(Team 1) == 0 || Number Of Players(Team 2) == 0) == True;
	}

	actions
	{
		Call Subroutine(FindRealPlayers);
		If(Count Of(Global.RealPlayers) == 1);
			Small Message(All Players(All Teams), Global.Texts[9]);
			Wait(1.500, Ignore Condition);
			"Skip victory screen on default victory when all but one players leave"
			Restart Match;
		Else;
			Global.GTemp[1] = Last Of(All Players(All Teams));
			Log To Inspector(Custom String("immediately moving \"{0}\" to {1}", Global.GTemp[1], Opposite Team Of(Team Of(Global.GTemp[1]))));
			"XXX: it might make sense to also end match by declaring draw but that somehow doesn't trigger IsBetweenRounds (in this case) and no cleanup happens which is an issue"
			Global.DBGMovedPlayersNum += 1;
			Move Player to Team(Global.GTemp[1], Opposite Team Of(Team Of(Global.GTemp[1])), -1);
		End;
	}
}

rule("Texts / HUD: Define texts for all UI / HUD elements")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"en-US (just for reference), credit for string comparisons goes to people behind https://workshop.codes/ auto translation system"
		disabled If(Custom String("{0}", Map(Practice Range)) == Custom String("Practice Range"));
		Global.Texts[0] = Custom String("Can self-ultimate      ");
		Global.Texts[1] = Custom String("Can ultimate mid-air");
		Global.Texts[2] = Custom String("Can grapple air / sky");
		Global.Texts[3] = Custom String("Stronger piledriver ");
		disabled Global.Texts[3] = Custom String("Empowered piledriver");
		Global.Texts[4] = Custom String("Hero tips");
		Global.Texts[5] = Custom String("HP");
		Global.Texts[6] = Custom String("Don't stray too far");
		Global.Texts[7] = Custom String("(HOLD)         ");
		Global.Texts[8] = Custom String("(NOT NOW)");
		Global.Texts[9] = Custom String("Everyone left - restarting...");
		Global.Texts[10] = Custom String("powered up!");
		Global.Texts[11] = Custom String("Round ends in:");
		Global.Texts[12] = Custom String("                       ");
		If(False);
		"de-DE"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Trainingsbereich"));
		"es-ES"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Práctica de combate"));
			disabled Global.Texts[4] = Custom String("Hero tips (in spanish)");
		"es-MX"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Campo de pruebas"));
		"fr-FR"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Champ de tir"));
		"it-IT"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Zona d'addestramento"));
		"ja-JP"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("練習場"));
		"ko-KR"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("훈련장"));
		"pl-PL"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Obszar treningowy"));
		"pt-BR"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("Campo de Treinamento"));
		"ru-RU"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("УЧЕБНЫЙ ПОЛИГОН"));
		"zh-CN"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("训练靶场"));
		"zh-TW"
		Else If(Custom String("{0}", Map(Practice Range)) == Custom String("訓練中心"));
	}
}

rule("Texts / HUD: Create permanent UI / HUD elements")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Global tips and HUDs"
		Create HUD Text(Array Contains(Global.ServerLoadVisibleTo, Custom String("{0}", Local Player)) ? Local Player : Null, Null,
			Custom String("{0}, {1}, {2}", Custom String("{0}% avg {1}% pk", Server Load Average, Server Load Peak), Custom String("{0}++",
			Global.Powerup_EmpoweredTeam ? Global.Powerup_EmpoweredTeam : String("None")), Custom String("R{0}/{1}, {2}", Match Round,
			Global.DBGRoundNum, Custom String("Pm{0}, Sk{1}", Global.DBGMovedPlayersNum, Global.LobbyBalance_WinStreak))), Null, Right, -1,
			Null, Custom Color(255, 255, 255, 80), Null, Visible To String and Color, Visible Always);
		Create HUD Text(Team Of(Local Player) == Global.Powerup_EmpoweredTeam ? Local Player : Null, Null, Null, Global.Powerup_HUDText,
			Left, 10, Null, Null, Color(Lime Green), Visible To and String, Visible Never);
		"NOTE: Don't use local player for fixed tips that everyone should see between rounds, they wont show to dead players spectating through teammate"
		Create HUD Text(Filtered Array(All Players(All Teams), !Global.IsRoundActive || Is Dead(Current Array Element)), Null, Null,
			Global.Texts[4], Left, 1, Null, Null, Color(Lime Green), Visible To, Visible Always);
		"NOTE: Disable any particular tip in the list below to hide it"
		Global.GTempArray1 = Empty Array;
		"tip: Ana self-ult"
		Global.GTempArray1[0] = Custom String("{0} {1} {2}", Hero Icon String(Hero(Ana)), Ability Icon String(Hero(Ana), Button(Ultimate)),
			Global.Texts[0]);
		"tip: Junk mid-air ult"
		Global.GTempArray1[1] = Custom String("{0} {1} {2}", Hero Icon String(Hero(Junkrat)), Ability Icon String(Hero(Junkrat), Button(
			Ultimate)), Global.Texts[1]);
		"tip: Hammond icicle grapple"
		Global.GTempArray1[2] = Custom String("{0} {1} {2}", Hero Icon String(Hero(Wrecking Ball)), Ability Icon String(Hero(
			Wrecking Ball), Button(Secondary Fire)), Global.Texts[2]);
		"tip: Hammond empowered piledriver"
		Global.GTempArray1[3] = Custom String("{0} {1} {2}", Hero Icon String(Hero(Wrecking Ball)), Ability Icon String(Hero(
			Wrecking Ball), Button(Crouch)), Global.Texts[3]);
		"Compile HUDs of all hero tips into big list visible between rounds"
		Global.GTemp[2] = 0;
		While(Global.GTemp[2] < Count Of(Global.GTempArray1));
			If(!Global.GTempArray1[Global.GTemp[2]]);
				Continue;
			End;
			Create HUD Text(Filtered Array(All Players(All Teams), !Global.IsRoundActive || Is Dead(Current Array Element)), Null,
				Global.GTempArray1[Global.GTemp[2]], Null, Left, 2, Null, Color(White), Null, Visible To, Visible Always);
			Global.GTemp[2] += 1;
		End;
		"Tips visible to specific heroes"
		If(Global.GTempArray1[0]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Ana) ? Local Player : Null, Null,
				Global.GTempArray1[0], Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		If(Global.GTempArray1[1]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Junkrat) ? Local Player : Null,
				Null, Global.GTempArray1[1], Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		If(Global.GTempArray1[2]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				&& Local Player.Hammond_GrappleIsOn ? Local Player : Null, Null, Custom String("{0} {1}", Global.GTempArray1[2],
				Global.Texts[8]), Null, Left, 2, Null, Custom Color(255, 255, 255, 50), Null, Visible To and Color, Visible Never);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				&& !Local Player.Hammond_GrappleIsOn ? Local Player : Null, Null, Custom String("{0} {1}", Global.GTempArray1[2],
				Global.Texts[7]), Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		If(Global.GTempArray1[3]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				? Local Player : Null, Null, Custom String("{0}{1}", Global.GTempArray1[3], Global.Texts[12]), Null, Left, 3, Null,
				Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		"HUD top spacing"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("\n\n\n"), Left, 0, Null, Null, Color(White), Visible To,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("\n\n\n"), Top, 0, Null, Null, Color(White), Visible To,
			Default Visibility);
	}
}

rule("Misc: HUD tip highlight")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsRoundActive == True;
	}

	actions
	{
		Global.HUDTipColor = Color(Orange);
		Wait(2, Ignore Condition);
		Global.HUDTipColor = Color(White);
	}
}

rule("Misc: Cleanup utility dummies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Although very rare, it is possible for a utility dummy (e.g. icicle grapple mei dummy) to not be deleted during game if the rule handling her is aborted (e.g. player leaving)"
		Is Dummy Bot(Event Player) == True;
		Slot Of(Event Player) > 3;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
	}
}

rule("Misc: Pre-game ult generation")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	conditions
	{
		"For the first ~3 seconds of the round ultimates to not generate so we have to calc it manually for some heroes during this"
		Global.IsRoundActive == True;
		Is Game In Progress == False;
	}

	actions
	{
		If(Hero Of(Event Player) == Hero(Soldier: 76));
			"Soldiers normal rounds do ~18 damage, we take this much for a +1% to charge"
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + Round To Integer(Event Damage / 20, Up));
		Else If(Hero Of(Event Player) == Hero(Cassidy));
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 1);
		End;
	}
}

rule("HP/Damage Balance: Powerup players belonging to smaller team")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsRoundStart == True;
		Number Of Players(Team Of(Event Player)) < Number Of Players(Opposite Team Of(Team Of(Event Player)));
	}

	actions
	{
		"This ensures rule is only called for one player in smaller team (since it will apply to everyone anyway)"
		Abort If(Global.Powerup_PlayersNumAdvantage > 0);
		Global.Powerup_PlayersNumAdvantage = Number Of Players(Opposite Team Of(Team Of(Event Player))) - Number Of Players(Team Of(
			Event Player));
		Global.GTemp[9] = Global.POWERUP_HPPERCENT * Global.Powerup_PlayersNumAdvantage;
		Global.GTemp[10] = Global.POWERUP_DAMAGEPERCENT * Global.Powerup_PlayersNumAdvantage;
		If(Number Of Players(Team Of(Event Player)) == 1);
			"Solo team override"
			Global.GTemp[9] = Global.POWERUP_HPPERCENT_SOLO * Global.Powerup_PlayersNumAdvantage;
			Global.GTemp[10] = Global.POWERUP_DAMAGEPERCENT_SOLO * Global.Powerup_PlayersNumAdvantage;
		End;
		Set Max Health(All Players(Team Of(Event Player)), 100 + Global.GTemp[9]);
		Set Damage Dealt(All Players(Team Of(Event Player)), 100 + Global.GTemp[10]);
		Global.Powerup_HUDText = Custom String("\n+{0}% {1} {2}", Global.GTemp[9], Global.Texts[5], Custom String("+{0}% {1}",
			Global.GTemp[10], String("Damage")));
		Global.Powerup_EmpoweredTeam = Team Of(Event Player);
		Log To Inspector(Custom String("powerup x{1} {0} (evt:{2})", Team Of(Event Player), Global.Powerup_PlayersNumAdvantage,
			Event Player));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("{0} {1}", Team Of(Event Player), Global.Texts[10]));
	}
}

rule("1v1 Time Limit: Prevent long 1v1s when others waiting")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The code of this entire \"1v1 Time Limit\" ruleset might feel overengineered, several reasons for it: dummy bots polluting player counts, match time being partially immutable in Elimination, not spawned players being counted as alive"
		Global.TimeLimit1v1_Triggers[3] == True;
	}

	actions
	{
		Abort If(Count Of(Global.RealAlivePlayers) != 2);
		Abort If(Count Of(Global.RealPlayers) - Count Of(Global.RealAlivePlayers) == 0);
		Global.GTemp[3] = 40;
		"Dont bother with countdown if match near ending (XXX: match time is 0 for a few seconds at the start of round)"
		Abort If(Match Time <= Global.GTemp[3] && Match Time != 0);
		Log To Inspector(Custom String("1v1 time limit countdown start"));
		While(Global.GTemp[3]);
			Abort If(!Global.IsRoundActive);
			"First 10 seconds we just count down silently and allow to cancel if someone is revived"
			If(Global.GTemp[3] > 30);
				Abort If(Count Of(Global.RealPlayers) - Count Of(Global.RealAlivePlayers) == 0);
			End;
			If(Global.GTemp[3] == 30);
				"This line is just to hide default countdown UI"
				Set Match Time(120);
				Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1}", Global.Texts[11], Global.GTemp[3]), Top, 1, Color(
					White), Color(White), Global.GTemp[3] > 10 ? Color(White) : Custom Color(250, 55, 65, 255), String and Color,
					Default Visibility);
				Global.TextIDS[0] = Last Text ID;
			End;
			Wait Until(!Global.IsRoundActive, 1);
			Global.GTemp[3] -= 1;
		End;
		Destroy HUD Text(Global.TextIDS[0]);
		Abort If(!Global.IsRoundActive);
		Log To Inspector(Custom String("1v1 time limit reached"));
		Abort If(Global.DBG);
		Declare Round Draw;
	}
}

rule("1v1 Time Limit: Prevent long 1v1s when others waiting (tracking and triggers)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"This entire rule needs to be separate from main rule. Even when merged which is logically seems easily doable it then stops detecting triggers inequalities *sometimes*."
		Global.IsRoundActive == True;
		(Global.TimeLimit1v1_Triggers[0] != Number Of Living Players(All Teams) || Global.TimeLimit1v1_Triggers[1] != Number Of Players(
			Team 1) || Global.TimeLimit1v1_Triggers[2] != Number Of Players(Team 2)) == True;
	}

	actions
	{
		"This trigger sets the main rule in motion, we reset it here to toggle on in a moment"
		Global.TimeLimit1v1_Triggers[3] = False;
		"Wait to ensure triggers update on next frame and not the same one as when change was detected (otherwise rule can get stuck in \"true\" state forever)"
		Wait(0.250, Ignore Condition);
		"These triggers track alive and total players so when anything like that changes we catch it in this rule"
		Global.TimeLimit1v1_Triggers[0] = Number Of Living Players(All Teams);
		Global.TimeLimit1v1_Triggers[1] = Number Of Players(Team 1);
		Global.TimeLimit1v1_Triggers[2] = Number Of Players(Team 2);
		Call Subroutine(FindRealPlayers);
		Abort If(!Global.IsRoundActive);
		Global.TimeLimit1v1_Triggers[3] = True;
	}
}

rule("Lobby Balance: Minimize team size difference and shuffle players when one team dominates")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBG != True;
		Global.IsRoundActive != True;
	}

	actions
	{
		"Wait before all utility bots are destroyed"
		Wait Until(!Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Slot Of(Current Array Element)
			> 3)), 2);
		">>> STEP 1: Ensure minimal size difference <<<"
		If(Workshop Setting Toggle(Custom String("Lobby Balance"), Custom String("Balance team sizes at round end"), True, 0));
			Global.GTemp[0] = Number Of Players(Team 1) - Number Of Players(Team 2);
			"NOTE: In case of teams being 1:4 players it will take 2 rounds to balance"
			If(Global.GTemp[0] > 1);
				Log To Inspector(Custom String("moving \"{0}\" to Team 2", Last Of(All Players(Team 1))));
				Global.DBGMovedPlayersNum += 1;
				Move Player to Team(Last Of(All Players(Team 1)), Team 2, -1);
			Else If(Global.GTemp[0] < -1);
				Log To Inspector(Custom String("moving \"{0}\" to Team 1", Last Of(All Players(Team 2))));
				Global.DBGMovedPlayersNum += 1;
				Move Player to Team(Last Of(All Players(Team 2)), Team 1, -1);
			End;
		End;
		">>> STEP 2: Swap players when one team dominates <<<"
		Global.GTemp[6] = Workshop Setting Integer(Custom String("Lobby Balance"), Custom String(
			"Swap random players when one team wins this many rounds in a row (0 to disable)"), 4, 0, 10, 1);
		Abort If(!Global.GTemp[6]);
		Abort If(Number Of Players(All Teams) <= 2);
		Global.GTemp[7] = Custom String("{0}-{1}-{2}", Number Of Players(Team 1), Number Of Players(Team 2),
			Global.LobbyBalance_VictorTeam);
		If(Global.GTemp[7] != Global.LobbyBalance_WinStreakID);
			Global.LobbyBalance_WinStreak = 0;
		End;
		Global.LobbyBalance_WinStreakID = Global.GTemp[7];
		Abort If(!Global.LobbyBalance_VictorTeam);
		Global.LobbyBalance_WinStreak += 1;
		Abort If(Global.LobbyBalance_WinStreak < Global.GTemp[6]);
		Global.LobbyBalance_WinStreak = 0;
		Global.GTemp[7] = Null;
		Global.GTemp[8] = Null;
		If(Number Of Players(Global.LobbyBalance_VictorTeam) >= Number Of Players(Opposite Team Of(Global.LobbyBalance_VictorTeam)));
			Global.DBGMovedPlayersNum += 1;
			Global.GTemp[7] = Random Value In Array(All Players(Team Of(Global.LobbyBalance_VictorTeam)));
		End;
		If(Number Of Players(Global.LobbyBalance_VictorTeam) == Number Of Players(Opposite Team Of(Global.LobbyBalance_VictorTeam)));
			Global.DBGMovedPlayersNum += 1;
			Global.GTemp[8] = Random Value In Array(All Players(Opposite Team Of(Global.LobbyBalance_VictorTeam)));
		End;
		Log To Inspector(Custom String("swapping teams for \"{0}\" and \"{1}\"", Global.GTemp[7], Global.GTemp[8]));
		Move Player to Team(Global.GTemp[7], Opposite Team Of(Team Of(Global.GTemp[7])), -1);
		Move Player to Team(Global.GTemp[8], Opposite Team Of(Team Of(Global.GTemp[8])), -1);
	}
}

rule("Lobby Balance: Randomize which team new players joins")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
		"Ensure our tracker variable is initialized"
		Count Of(Global.LobbyBalance_LastSeenPlayers) > 0;
	}

	actions
	{
		Abort If(!Workshop Setting Toggle(Custom String("Lobby Balance"), Custom String(
			"Put new players in random team (when teams are of equal size)"), True, 2));
		"Dont do anything if player was simply moved to Team 1 by unrelated action"
		Abort If(Array Contains(Global.LobbyBalance_LastSeenPlayers, Event Player));
		Call Subroutine(FindRealPlayers);
		Global.LobbyBalance_LastSeenPlayers = Global.RealPlayers;
		"By default new players will be slotted into Team 1, we introduce a 50% chance for them to be moved to Team 2 if teams were equal before they arrived"
		Abort If(Random Integer(0, 1));
		"Add a momentary wait to space out the swapping, may address issues of occasional burst of new players joining"
		Wait(Random Real(0.100, 0.400), Ignore Condition);
		"Recalculate real players as it may have changed after last wait"
		Call Subroutine(FindRealPlayers);
		"If Team 2 is larger or equal size, no need to move"
		Global.GTemp[4] = Count Of(Filtered Array(Global.RealPlayers, Team Of(Current Array Element) == Team 1));
		Global.GTemp[5] = Count Of(Filtered Array(Global.RealPlayers, Team Of(Current Array Element) == Team 2));
		Abort If(Global.GTemp[5] >= Global.GTemp[4]);
		Log To Inspector(Custom String("randomly moving new player \"{0}\" to Team 2", Event Player));
		Global.DBGMovedPlayersNum += 1;
		Move Player to Team(Event Player, Team 2, -1);
	}
}

rule("Sub: Find all real players")
{
	event
	{
		Subroutine;
		FindRealPlayers;
	}

	actions
	{
		"NOTE: For debugging purposes we treat dummies in player slots (0-3) as real players"
		Global.RealPlayers = Filtered Array(All Players(All Teams), !(Is Dummy Bot(Current Array Element) && Slot Of(Current Array Element)
			> 3));
		"This also excludes not spawned players. Joined but not spawned players count as alive which is usually undesirable."
		Global.RealAlivePlayers = Filtered Array(Global.RealPlayers, Is Alive(Current Array Element) && Has Spawned(
			Current Array Element));
	}
}

rule("Hero: Ana (self ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is Dummy Bot(Event Player) == False;
		(Hero Of(Event Player) == Hero(Ana) || Hero Being Duplicated(Event Player) == Hero(Ana)) == True;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(Event Player, Stunned)) == False;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 0);
		Create Dummy Bot(Hero(Ana), Team Of(Event Player), 10, Vector(0, 0, 0), Vector(0, 0, 0));
		Set Invisible(Players In Slot(10, Team Of(Event Player)), All);
		Start Forcing Dummy Bot Name(Players In Slot(10, Team Of(Event Player)), Custom String("Ana Apparition"));
		Start Forcing Player Position(Players In Slot(10, Team Of(Event Player)), Position Of(Event Player) + Vector(0, 5, 1), False);
		Set Status(Players In Slot(10, Team Of(Event Player)), Null, Phased Out, 9999);
		Start Facing(Players In Slot(10, Team Of(Event Player)), Direction Towards(Players In Slot(10, Team Of(Event Player)),
			Event Player), 1000, To World, Direction and Turn Rate);
		Wait(0.400, Ignore Condition);
		Press Button(Players In Slot(10, Team Of(Event Player)), Button(Ultimate));
		"Support line for when Echo ults as Ana"
		Event Player.Echo_DupeUlted = True;
		Wait Until((Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) != True, 9);
		Destroy Dummy Bot(Team Of(Event Player), 10);
	}
}

rule("Hero: Hammond (icicle grapple - icicle spawning)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.Hammond_GrappleIsOn == False;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(Event Player, Stunned)) == False;
	}

	actions
	{
		"Position of where a fake icicle should be created (what hammond is looking at)."
		Event Player.Hammond_IciclePos = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 13, Null, Null, True);
		"Prevent underground icicle"
		If(Y Component Of(Event Player.Hammond_IciclePos) < 0.700);
			Event Player.Hammond_IciclePos = Vector(X Component Of(Event Player.Hammond_IciclePos), 0.700, Z Component Of(
				Event Player.Hammond_IciclePos));
		End;
		Create Dummy Bot(Hero(Mei), Team Of(Event Player), 11, Event Player.Hammond_IciclePos - Vector(0, 0.300, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(11, Team Of(Event Player)), Custom String("Icicle"));
		Start Forcing Player Position(Players In Slot(11, Team Of(Event Player)), Position Of(Players In Slot(11, Team Of(Event Player))),
			True);
		Set Invisible(Players In Slot(11, Team Of(Event Player)), All);
		Wait(0.065, Ignore Condition);
		Press Button(Players In Slot(11, Team Of(Event Player)), Button(Ability 1));
		Wait(1, Ignore Condition);
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)), 3);
		Destroy Dummy Bot(Team Of(Event Player), 11);
	}
}

rule("Hero: Hammond (icicle grapple - when grapple disabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Global.IsRoundActive == True;
		(Absolute Value(X Component Of(Position Of(Event Player))) > 19.700 || Absolute Value(Z Component Of(Position Of(Event Player)))
			> 19.700 || Entity Exists(Players In Slot(11, Team Of(Event Player)))) == False;
	}

	actions
	{
		Event Player.Hammond_GrappleIsOn = False;
		Disallow Button(Event Player, Button(Secondary Fire));
	}
}

rule("Hero: Hammond (icicle grapple - when grapple enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Global.IsRoundActive == True;
		(Absolute Value(X Component Of(Position Of(Event Player))) > 19.700 || Absolute Value(Z Component Of(Position Of(Event Player)))
			> 19.700 || Entity Exists(Players In Slot(11, Team Of(Event Player)))) == True;
	}

	actions
	{
		"If icicle was created"
		If(Entity Exists(Players In Slot(11, Team Of(Event Player))));
			Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.Hammond_IciclePos), 10000, To World,
				Direction and Turn Rate);
			"Allow some time for focus to snap onto icicle"
			Wait(0.170, Ignore Condition);
			Event Player.Hammond_GrappleIsOn = True;
			Allow Button(Event Player, Button(Secondary Fire));
			"Resetting ability triggers grapple to fire again when held"
			Set Secondary Fire Enabled(Event Player, False);
			Set Secondary Fire Enabled(Event Player, True);
			Stop Facing(Event Player);
		"If simply outside of island range"
		Else;
			Event Player.Hammond_GrappleIsOn = True;
			Allow Button(Event Player, Button(Secondary Fire));
		End;
	}
}

rule("Hero: Hammond (piledriver buff)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Crouch)) > 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
	}

	actions
	{
		Start Damage Modification(All Players(All Teams), Event Player, 210, Receivers Damagers and Damage Percent);
		Event Player.PTemp[4] = Last Damage Modification ID;
		Set Knockback Dealt(Event Player, 115);
		Wait Until(Vertical Speed Of(Event Player) == 0, 2);
		Wait(0.250, Ignore Condition);
		Set Knockback Dealt(Event Player, 100);
		Stop Damage Modification(Event Player.PTemp[4]);
	}
}

disabled rule("Hero: Hammond (empowered piledriver)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Crouch)) > 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
	}

	actions
	{
		">>>>>>>>>>>>>>>>>>>>>>>>> SETUP, CALC POWERUP <<<<<<<<<<<<<<<<<<<<<<<<<"
		Event Player.ChaserVar1 = 1;
		Event Player.ChaserVar2 = 1;
		"Estimate as to where the ball shall land"
		Event Player.PTemp[8] = Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(Position Of(Event Player))) + Vector(
			X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))) * 5;
		"Current distance from landing"
		Event Player.PTemp[9] = Distance Between(Event Player.PTemp[8], Position Of(Event Player));
		"Distance from landing into radius multiplier (+1x size every 13 meters, maximum of 3x)"
		Event Player.PTemp[10] = 1 + Min(Event Player.PTemp[9] / 13, 2);
		"Static damage and knockback powerups of inner ring"
		Start Damage Modification(All Players(All Teams), Event Player, 200, Receivers Damagers and Damage Percent);
		Event Player.PTemp[4] = Last Damage Modification ID;
		Set Knockback Dealt(Event Player, 115);
		Start Scaling Player(Event Player, Event Player.ChaserVar1, True);
		">>>>>>>>>>>>>>>>>>>>>>>>> APPLY VISUAL EFFECTS <<<<<<<<<<<<<<<<<<<<<<<<<"
		Create Effect(Event Player, Ring, Color(Gray), Event Player.PTemp[8], 8, Position and Radius);
		Event Player.PTemp[6] = Last Created Entity;
		Create Effect(Event Player, Ring, Color(White), Event Player.PTemp[8], 8 * Event Player.ChaserVar2, Position and Radius);
		Event Player.PTemp[7] = Last Created Entity;
		"Scale outer ring"
		Chase Player Variable Over Time(Event Player, ChaserVar2, Event Player.PTemp[10], 0.500, None);
		"Wait untill the rollout animation completes"
		Wait(0.100, Ignore Condition);
		Wait Until(Speed Of In Direction(Event Player, Down) > 0, 1);
		"Scale player (exaggerate final size slightly, devide distance by 150 meters for the animation speed)"
		Chase Player Variable Over Time(Event Player, ChaserVar1, Event Player.PTemp[10] * 1.300, Event Player.PTemp[9] / 150, None);
		Wait Until(Vertical Speed Of(Event Player) == 0, 1);
		">>>>>>>>>>>>>>>>>>>>>>>>> LANDING, IMMEDIATE CLEANUP <<<<<<<<<<<<<<<<<<<<<<<<<"
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Stop Chasing Player Variable(Event Player, ChaserVar2);
		Destroy Effect(Event Player.PTemp[6]);
		Destroy Effect(Event Player.PTemp[7]);
		"Scale player back down (better idea was to scale in two instant steps: half to original then to original, split by .1s waits, looks way better but too janky for hammond)"
		Chase Player Variable Over Time(Event Player, ChaserVar1, 1, 0.130, None);
		">>>>>>>>>>>>>>>>>>>>>>>>> FIND VICTIMS AND FLAG THEM TO BE HARMED <<<<<<<<<<<<<<<<<<<<<<<<<"
		Call Subroutine(FindRealPlayers);
		Event Player.PTempArray1 = Filtered Array(Global.RealAlivePlayers, Team Of(Current Array Element) != Team Of(Event Player));
		Event Player.PTemp[11] = 0;
		While(Event Player.PTemp[11] < Count Of(Event Player.PTempArray1));
			Event Player.PTemp[12] = Event Player.PTempArray1[Event Player.PTemp[11]];
			Event Player.PTemp[11] += 1;
			Event Player.PTemp[13] = Distance Between(Position Of(Event Player.PTemp[12]), Event Player);
			Skip If(Event Player.PTemp[13] < 8 * Event Player.PTemp[10] && !Has Status(Event Player.PTemp[12], Phased Out) && !Has Status(
				Event Player.PTemp[12], Invincible), 1);
			Continue;
			Skip If(Event Player.PTemp[12].Hammond_PiledriverHarmFlag != -1, 1);
			Continue;
			"Barrier detection (BUG: can be blind to barriers which  have an enemy stand in the middle of it and that enemy is also between victim and ball)"
			Event Player.PTemp[14] = Position Of(Event Player) + Vector(0, 1, 0);
			Event Player.PTemp[15] = Position Of(Event Player.PTemp[12]) + Vector(0, 1, 0);
			Event Player.PTemp[16] = 0;
			While(Event Player.PTemp[16] < 3);
				"Cast ray from attacker to victim"
				Event Player.PTemp[17] = Ray Cast Hit Player(Event Player.PTemp[14], Event Player.PTemp[15], Event Player.PTempArray1, Null, True);
				"We reached player"
				If(Event Player.PTemp[17] == Event Player.PTemp[12]);
					Event Player.PTemp[12].Hammond_PiledriverHarmFlag = Event Player;
					Break;
				"We reached non player obstacle"
				Else If(!Event Player.PTemp[17]);
					Break;
				End;
				"We detected another player in the way, reverse cast the ray to find that player opposite side and move our ray origin there"
				Event Player.PTemp[18] = Ray Cast Hit Player(Event Player.PTemp[15], Event Player.PTemp[14], Event Player.PTemp[17], Null, False);
				Event Player.PTemp[14] = Ray Cast Hit Position(Event Player.PTemp[15], Event Player.PTemp[14], Event Player.PTemp[17], Null,
					False);
				Event Player.PTemp[14] += Normalize(Event Player.PTemp[14]) * 0.010;
				"If we hit non player obstacle on the way from target to back of collided player means that obstacle also protects victim"
				If(!Event Player.PTemp[18]);
					Break;
				End;
				Event Player.PTemp[16] += 1;
			End;
		End;
		">>>>>>>>>>>>>>>>>>>>>>>>> FINAL CLEANUP <<<<<<<<<<<<<<<<<<<<<<<<<"
		Skip(0);
		"Short wait to ensure all damages taken place"
		Wait(0.250, Ignore Condition);
		Set Knockback Dealt(Event Player, 100);
		Stop Damage Modification(Event Player.PTemp[4]);
		"Wait until we scaled the player back down"
		Wait Until(Event Player.ChaserVar1 == 1, 1);
		Stop Chasing Player Variable(Event Player, ChaserVar2);
		Stop Scaling Player(Event Player);
	}
}

disabled rule("Hero: Hammond (empowered piledriver - harm bonus victims)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Hammond_PiledriverHarmFlag != Null;
		Event Player.Hammond_PiledriverHarmFlag != -1;
	}

	actions
	{
		Wait Until(Event Player.Hammond_PiledriverHarmFlag == -1, 0.100);
		Abort If(Event Player.Hammond_PiledriverHarmFlag == -1);
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		Wait(0.016, Ignore Condition);
		Stop Forcing Player Position(Event Player);
		Damage(Event Player, Event Player.Hammond_PiledriverHarmFlag, 20);
		Play Effect(Event Player, Explosion Sound, Color(White), Event Player, 70);
		Apply Impulse(Event Player, Up + 0.650 * Direction Towards(Position Of(Event Player), Event Player.Hammond_PiledriverHarmFlag),
			Array Contains(All Tank Heroes, Hero Of(Event Player)) ? 11 : 13.500, To World, Cancel Contrary Motion);
		Set Move Speed(Event Player, 20);
		Wait(0.500, Ignore Condition);
		Event Player.PTemp[19] = 1;
		While(Event Player.PTemp[19] < 5);
			If(Event Player.PTemp[19] > 1);
				Wait(0.100, Ignore Condition);
			End;
			Set Move Speed(Event Player, 20 + 20 * Event Player.PTemp[19]);
			Event Player.PTemp[19] += 1;
		End;
		Event Player.Hammond_PiledriverHarmFlag = Null;
	}
}

disabled rule("Hero: Hammond (empowered piledriver - prevent double damage)")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Event Ability == Button(Crouch);
		Hero Of(Attacker) == Hero(Wrecking Ball);
	}

	actions
	{
		Event Player.Hammond_PiledriverHarmFlag = -1;
		Wait(0.300, Ignore Condition);
		Event Player.Hammond_PiledriverHarmFlag = Null;
	}
}

disabled rule("Hero: Hammond (empowered piledriver - hovering guide circle)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Y Component Of(Position Of(Event Player)) > 2;
		Ability Cooldown(Event Player, Button(Crouch)) == 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
	}

	actions
	{
		Create Effect(Event Player, Ring, Color(Gray), Update Every Frame(Vector(X Component Of(Position Of(Event Player)), 0,
			Z Component Of(Position Of(Event Player))) + Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(
			Facing Direction Of(Event Player))) * 5), 8, Position and Radius);
		Event Player.PTemp[5] = Last Created Entity;
		Wait Until(Y Component Of(Position Of(Event Player)) <= 2 || Ability Cooldown(Event Player, Button(Crouch)) > 0 || !Is Alive(
			Event Player) || !Entity Exists(Event Player) || !Global.IsRoundActive || (Hero Of(Event Player) == Hero(Wrecking Ball)
			|| Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) != True, 9999);
		Destroy Effect(Event Player.PTemp[5]);
	}
}

rule("Hero: Junkrat (mid-air ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		(Hero Of(Event Player) == Hero(Junkrat) || Hero Being Duplicated(Event Player) == Hero(Junkrat)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(Event Player, Stunned)) == False;
	}

	actions
	{
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		Create Dummy Bot(Hero(Mei), Team Of(Event Player), 8, Position Of(Event Player) - Vector(0, 2.600, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(8, Team Of(Event Player)), Custom String("Icicle"));
		Set Invisible(Players In Slot(8, Team Of(Event Player)), All);
		Start Forcing Player Position(Players In Slot(8, Team Of(Event Player)), Position Of(Players In Slot(8, Team Of(Event Player))),
			False);
		Wait(0.065, Ignore Condition);
		Press Button(Players In Slot(8, Team Of(Event Player)), Button(Ability 1));
		Stop Forcing Player Position(Event Player);
		Wait Until(!Is In Air(Event Player), 1);
		Press Button(Event Player, Button(Ultimate));
		Destroy Dummy Bot(Team Of(Event Player), 8);
	}
}

rule("Hero: D.Va (start with an ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
	}

	actions
	{
		"NOTE: We are setting ult to 100% in the rules instead of settings because the setting makes her gain 100% ult every time she re-mechs."
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Hero: Soldier 76 (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Soldier: 76;
	}

	conditions
	{
		Global.IsRoundActive == True;
		"This ensure this also triggers on resurrect"
		Is Alive(Event Player) == True;
	}

	actions
	{
		"Value is tweaked with respect to \"Pre-game ult generation\""
		Set Ultimate Charge(Event Player, 95);
	}
}

rule("Hero: McCree (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Cassidy;
	}

	conditions
	{
		Global.IsRoundActive == True;
		"This ensure this also triggers on resurrect"
		Is Alive(Event Player) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 98);
	}
}

rule("Hero: Lifeweaver (ult duration)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Event Player.ChaserVar1 = 100;
		Event Player.PTemp[0] = Eye Position(Event Player);
		Event Player.PTemp[1] = Eye Position(Event Player) + Facing Direction Of(Event Player) * 40;
		"Wait for tree to spawn"
		Wait(0.250, Ignore Condition);
		"Cast ray from recorded eye position to recorded position these eyes were looking at, find a tree hit by the ray, shift found position upwards by 1 and away from eyes by 2 to center into tree trunk"
		Event Player.PTemp[1] = Ray Cast Hit Position(Event Player.PTemp[0], Event Player.PTemp[1], Null, Null, True)
			+ Facing Direction Of(Event Player) * Vector(2, 0, 2) + Vector(0, 1, 0);
		disabled Create Effect(All Players(All Teams), Sphere, Color(Red), Event Player.PTemp[1], 1, None);
		Create Progress Bar In-World Text(All Players(Team Of(Event Player)), Event Player.ChaserVar1, Null, Event Player.PTemp[1], 0.750,
			Do Not Clip, Custom Color(255, 235, 130, 255), Null, Values, Default Visibility);
		Event Player.TextIDS[0] = Last Text ID;
		Chase Player Variable Over Time(Event Player, ChaserVar1, 0, 7, None);
		Wait Until(Event Player.ChaserVar1 == 0, 15);
		Press Button(Event Player, Button(Ultimate));
		Destroy Progress Bar In-World Text(Event Player.TextIDS[0]);
	}
}

rule("Hero: Lifeweaver (ult duration - cleanup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		"XXX: normally there seems to be no way to reliably detect tree being destroyed, as a hacky workaround we just check if weaver starts building ult again, meaning there is no tree active"
		Ultimate Charge Percent(Event Player) > 0;
		Event Player.ChaserVar1 != 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Destroy Progress Bar In-World Text(Event Player.TextIDS[0]);
	}
}

rule("Hero: Winstor (limit barrier HP)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Global.IsRoundActive == True;
		(Hero Of(Event Player) == Hero(Winston) || Hero Being Duplicated(Event Player) == Hero(Winston)) == True;
	}

	actions
	{
		Event Player.PTemp[2] = Position Of(Event Player);
		"Atop the edge of shield border"
		Event Player.PTemp[3] = Position Of(Event Player) + Vector(0, 5.400, 0);
		"We create a dummy bot in the opposite team for it to own the projectile. Granting ownership to null or arbitrary opposite team member has side effects and incosistencies."
		Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Event Player)), 7, Vector(0, -2, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(7, Opposite Team Of(Team Of(Event Player))), Custom String("Apparition"));
		Set Invisible(Players In Slot(7, Opposite Team Of(Team Of(Event Player))), All);
		Wait(0.100, Ignore Condition);
		Create Projectile(Orb Projectile, Players In Slot(7, Opposite Team Of(Team Of(Event Player))), Event Player.PTemp[3],
			Direction Towards(Event Player.PTemp[3], Event Player.PTemp[2]), To World, Damage, Team Of(Event Player), 340, 0, 0,
			Bad Explosion, Explosion Sound, 0, 0.100, 0.200, 0, 0, 0);
		Wait(0.200, Ignore Condition);
		Destroy Dummy Bot(Opposite Team Of(Team Of(Event Player)), 7);
	}
}

rule("Hero: Echo (support others faux abilities)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Echo;
	}

	conditions
	{
		"Most of the support is added via hero specific rule conditions, this is currently just setup for later cleanup"
		Is Duplicating(Event Player) == True;
	}

	actions
	{
		Event Player.Echo_JustDuplicated = Hero Being Duplicated(Event Player);
		Event Player.Echo_DupeUlted = Null;
		Wait Until(Is Using Ultimate(Event Player) && Is Duplicating(Event Player), 9999);
		Event Player.Echo_DupeUlted = True;
	}
}

rule("Hero: Echo (support others faux abilities - cleanup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Echo;
	}

	conditions
	{
		Is Duplicating(Event Player) != True;
		Event Player.Echo_JustDuplicated != Null;
	}

	actions
	{
		Allow Button(Event Player, Button(Secondary Fire));
		If(Event Player.Echo_JustDuplicated == Hero(Ana) && Event Player.Echo_DupeUlted);
			Destroy Dummy Bot(Team Of(Event Player), 10);
		End;
		Event Player.Echo_JustDuplicated = Null;
	}
}

disabled rule("DBG: Main toggle")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DBG = True;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("DBG {0}", Global.DBGMsg), Right, 0, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("DBG: Enable hero select")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DBGAllowHeroSelect = 8;
	}
}

rule("DBG: Server load view toggler")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		If(Array Contains(Global.ServerLoadVisibleTo, Custom String("{0}", Event Player)));
			Global.ServerLoadVisibleTo = Remove From Array(Global.ServerLoadVisibleTo, Custom String("{0}", Event Player));
		Else;
			Global.ServerLoadVisibleTo = Append To Array(Global.ServerLoadVisibleTo, Custom String("{0}", Event Player));
	}
}

rule("DBG: Persistent dummy bots")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Total Time Elapsed < 3;
		Event Player == Host Player;
	}

	actions
	{
		Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 0, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 1, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 2, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 3, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 1, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 2, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 3, Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

rule("DBG: Persistent bot shooting toggler")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Event Player == Host Player;
	}

	actions
	{
		Global.DBGBotShooting = !Global.DBGBotShooting;
	}
}

rule("DBG: Persistent bot aim and shoot")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBGBotShooting == True;
		Slot Of(Event Player) == 0;
		Is Dummy Bot(Event Player) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Start Facing(Event Player, Direction From Angles(90, 3), 100, To Player, None);
		While(True);
			Wait(2, Ignore Condition);
			Press Button(Event Player, Button(Primary Fire));
			Abort If(!Global.DBGBotShooting);
		End;
	}
}

rule("DBG: Melee actions (for dev drafts)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Melee DBG"));
	}
}