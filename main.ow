settings
{
	main
	{
		Description: "All new OW2 heroes. Code: 48CYD\n- Hammond can grapple air.\n- Ana can self-ult.\n- Junk can ult mid-air.\n- D.Va doesn't get infinite nukes.\n- Ballance changes.\n- Anti-winston-trolling (limited airspace).\n\nVer:1.5dev. All changes and info at:\ngithub.com/domuspopus/overwatch-4v4-all-heroes"
		Mode Name: "4v4 All Heroes (J-edit)"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: Paused
		Match Voice Chat: Enabled
		Max Team 1 Players: 4
		Max Team 2 Players: 4
		Return To Lobby: Never
		Swap Teams After Match: No
		Team Balancing: After A Game
	}

	modes
	{
		Elimination
		{
			enabled maps
			{
				Workshop Island 972777519512063901
				Workshop Island Night 972777519512064579
			}
		}

		General
		{
			Allow Hero Switching: Off
			Capture Objective Tiebreaker: Off
			Game Mode Start: Immediately
			Respawn As Random Hero: On
			Respawn Time Scalar: 0%
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 25%
			Spawn With Ultimate Ready: On
			Ultimate Generation: 200%
			Ultimate Generation - Combat: 130%

			Cassidy
			{
				Spawn With Ultimate Ready: Off
				Ultimate Generation - Combat Deadeye: 200%
				Ultimate Generation - Passive Deadeye: 10%
			}

			D.Va
			{
				Self Destruct Knockback Scalar: 200%
				Spawn With Ultimate Ready: Off
			}

			Junkrat
			{
				Concussion Mine Knockback Scalar: 120%
			}

			Lifeweaver
			{
				Petal Platform Health: 25%
				Tree of Life Health: 50%
			}

			Mercy
			{
				Health: 85%
				Resurrect Cooldown Time: 60%
			}

			Moira
			{
				Biotic Orb Cooldown Time: 45%
				Fade Cooldown Time: 35%
				Health: 85%
				Spawn With Ultimate Ready: Off
			}

			Orisa
			{
				Health: 50%
			}

			Reinhardt
			{
				Ultimate Generation - Passive Earthshatter: 400%
			}

			Roadhog
			{
				Health: 65%
				Spawn With Ultimate Ready: Off
			}

			Soldier: 76
			{
				Spawn With Ultimate Ready: Off
				Ultimate Duration: 50%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 10%
				Venom Mine Cooldown Time: 5%
			}

			Winston
			{
				Barrier Projector Cooldown Time: 35%
				Damage Dealt: 130%
				Health: 75%
			}

			Wrecking Ball
			{
				Grappling Claw Knockback Scalar: 115%
				Health: 65%
			}

			Zarya
			{
				Health: 65%
			}
		}
	}
}

variables
{
	global:
		0: IsRoundActive
		1: IsRoundStart
		2: TextIDS
		3: Powerup_HPPercent
		4: Powerup_DamagePercent
		5: Powerup_PlayersNumAdvantage
		6: MapBoundry_Vertical
		7: MapBoundry_Horizontal
		8: TimeLimit1v1_Countdown
		9: HUDTipColor
		10: Tips
		11: Temp
		22: DBGAllowHeroSelect
		23: DBGMsg
		24: DBGBotShooting
		25: DBG

	player:
		0: TextIDS
		1: Hammond_GrappleIsOn
		2: Hammond_IciclePos
		3: ServerLoadVisible
		4: ChaserVar1
		5: Temp
		6: Echo_JustDuplicated
		7: Echo_DupeUlted
}

rule("NOTES/TODO'S")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"INFO: The general Ultimate Generation setting multiplies with specific ones (combat/passive). So when you set passive generation to say 200% and general to 200%, your passive will result in 400%."
		Abort;
		"INFO: Avoid default IsGameInProgress as it turns true only several seconds after round actually starts, prefer Global.IsRoundActive."
		Abort;
		"NOTE: Avoid default IsBetweenRounds as it turns false far too early in the start of the round, sometimes even when player is still indicated to have previous round hero."
		Abort;
		"NOTE: \"Temp\" variable (array of) is used for short lived, disposable varibales."
		Abort;
		"XXX: Some functionality such as hp/damage ballancer or 1v1 time limit might occasionally take into account dummy players created by faux abilities. It is not a noticable issue as of yet."
		Abort;
		"BUG: Ultimates wont start generating for a few seconds in the start of match (need \"Is Game In Progress = True\"). This is an issue for characters that don't start with ult ready."
		Abort;
	}
}

rule("Base: Set global variables and show UI tips")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Auto-ballancing variables. Bumps percentage of HP / damage of each player in smaller team."
		Global.Powerup_HPPercent = 20;
		Global.Powerup_DamagePercent = 30;
		"Map boundaries"
		Global.MapBoundry_Vertical = 25;
		Global.MapBoundry_Horizontal = 45;
		"Misc"
		Disable Built-In Game Mode Announcer;
		Global.TimeLimit1v1_Countdown = -1;
		Create HUD Text(True ? Local Player.ServerLoadVisible : Null, Null, Custom String("Server load {0}% avg {1}% peak",
			Server Load Average, Server Load Peak), Null, Right, -1, Null, Server Load Average < 70 ? Custom Color(255, 255, 255, 50)
			: Custom Color(255, 0, 0, 120), Null, Visible To String and Color, Visible Always);
		"Global tips (NOTE: avoid using local player for general tips that everyone should see between rounds)"
		Create HUD Text(Filtered Array(All Players(All Teams), !Global.IsRoundActive || Is Dead(Current Array Element)), Null, Null,
			Custom String("Hero tips"), Left, 1, Null, Null, Color(Lime Green), Visible To, Visible Always);
		Global.Tips = Empty Array;
		Modify Global Variable(Tips, Append To Array, Custom String("{0} {1} Can self-ultimate      ", Hero Icon String(Hero(Ana)),
			Ability Icon String(Hero(Ana), Button(Ultimate))));
		Modify Global Variable(Tips, Append To Array, Custom String("{0} {1} Can ultimate mid-air", Hero Icon String(Hero(Junkrat)),
			Ability Icon String(Hero(Junkrat), Button(Ultimate))));
		Modify Global Variable(Tips, Append To Array, Custom String("{0} {1} Can grapple air / sky", Hero Icon String(Hero(Wrecking Ball)),
			Ability Icon String(Hero(Wrecking Ball), Button(Secondary Fire))));
		Modify Global Variable(Tips, Append To Array, Custom String("{0} {1} Stronger piledriver ", Hero Icon String(Hero(Wrecking Ball)),
			Ability Icon String(Hero(Wrecking Ball), Button(Crouch))));
		Global.Temp[2] = 0;
		While(Global.Temp[2] < Count Of(Global.Tips));
			Create HUD Text(Filtered Array(All Players(All Teams), !Global.IsRoundActive || Is Dead(Current Array Element)), Null,
				Global.Tips[Global.Temp[2]], Null, Left, 2, Null, Color(White), Null, Visible To, Visible Always);
			Global.Temp[2] += 1;
		End;
		"Show hero specific tips"
		Global.Temp[2] = First Of(Filtered Array(Global.Tips, String Contains(Current Array Element, Ability Icon String(Hero(Ana), Button(
			Ultimate)))));
		If(Global.Temp[2]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Ana) ? Local Player : Null, Null,
				Global.Temp[2], Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		Global.Temp[2] = First Of(Filtered Array(Global.Tips, String Contains(Current Array Element, Ability Icon String(Hero(Junkrat),
			Button(Ultimate)))));
		If(Global.Temp[2]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Junkrat) ? Local Player : Null,
				Null, Global.Temp[2], Null, Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		Global.Temp[2] = First Of(Filtered Array(Global.Tips, String Contains(Current Array Element, Ability Icon String(Hero(
			Wrecking Ball), Button(Secondary Fire)))));
		If(Global.Temp[2]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				&& Local Player.Hammond_GrappleIsOn ? Local Player : Null, Null, Custom String("{0} (NOT NOW)", Global.Temp[2]), Null, Left, 2,
				Null, Custom Color(255, 255, 255, 50), Null, Visible To and Color, Visible Never);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				&& !Local Player.Hammond_GrappleIsOn ? Local Player : Null, Null, Custom String("{0} (HOLD)         ", Global.Temp[2]), Null,
				Left, 2, Null, Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		Global.Temp[2] = First Of(Filtered Array(Global.Tips, String Contains(Current Array Element, Ability Icon String(Hero(
			Wrecking Ball), Button(Crouch)))));
		If(Global.Temp[2]);
			Create HUD Text(Global.IsRoundActive && Is Alive(Local Player) && Hero Of(Local Player) == Hero(Wrecking Ball)
				? Local Player : Null, Null, Custom String("{0}                        ", Global.Temp[2]), Null, Left, 3, Null,
				Global.HUDTipColor, Null, Visible To and Color, Visible Never);
		End;
		"HUD spacing"
		Create HUD Text(All Players(All Teams), Null, Custom String("{0} {1}", Custom String(""), Custom String("")), Custom String(
			"{0} {1}", Custom String(""), Custom String("")), Left, 0, Color(White), Color(White), Color(White), Visible To,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Custom String("{0} {1}", Custom String(""), Custom String("")), Custom String(
			"{0} {1}", Custom String(""), Custom String("")), Left, 0, Color(White), Color(White), Color(White), Visible To,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Custom String("{0} {1}", Custom String(""), Custom String("")), Custom String(
			"{0} {1}", Custom String(""), Custom String("")), Top, 0, Color(White), Color(White), Color(White), Visible To,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Custom String("{0} {1}", Custom String(""), Custom String("")), Custom String(
			"{0} {1}", Custom String(""), Custom String("")), Top, 0, Color(White), Color(White), Color(White), Visible To,
			Default Visibility);
	}
}

rule("Base: Skip hero select, initiate round start variables")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		"Disable inspector in live game"
		If(!Global.DBG);
			Disable Inspector Recording;
		End;
		"Allow time to select in debug mode"
		If(Global.DBGAllowHeroSelect);
			Set Match Time(Global.DBGAllowHeroSelect);
			Wait(Global.DBGAllowHeroSelect, Ignore Condition);
		End;
		"This skips the selection"
		Set Match Time(0);
		"Allow time for game to select hero for player and initiate round"
		Wait(0.250, Ignore Condition);
		Global.IsRoundActive = True;
		Global.IsRoundStart = True;
		Log To Inspector(Custom String(">>> round #{0} start", Match Round));
		Wait(0.250, Ignore Condition);
		Global.IsRoundStart = False;
	}
}

rule("Base: Round end (cleanup)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Team Score(Team 1) > 0 || Team Score(Team 2) > 0 || Is Between Rounds) == True;
	}

	actions
	{
		Log To Inspector(Custom String(">>> round end"));
		Set Team Score(All Teams, 0);
		Global.IsRoundActive = False;
		Global.Powerup_PlayersNumAdvantage = 0;
		Global.TimeLimit1v1_Countdown = -1;
		Stop All Healing Modifications;
		Stop All Damage Modifications;
		Stop All Damage Over Time(All Players(All Teams));
		Stop Forcing Player Position(All Players(All Teams));
		Set Damage Dealt(All Players(All Teams), 100);
		Set Max Health(All Players(All Teams), 100);
		Allow Button(All Players(All Teams), Button(Secondary Fire));
		Destroy HUD Text(Global.TextIDS[0]);
		Set Knockback Dealt(All Players(All Teams), 100);
		Destroy All In-World Text;
		Destroy All Progress Bar In-World Text;
	}
}

rule("Base: Round end (cleanup - per player)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsRoundActive != True;
	}

	actions
	{
		"Destroy bots in slots 4-11, these are used for temporary dummy bots for faux abilities etc."
		If(Is Dummy Bot(Event Player) && Slot Of(Event Player) > 3);
			Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
		End;
		Destroy HUD Text(Event Player.TextIDS[0]);
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Event Player.Echo_JustDuplicated = Null;
	}
}

rule("Base: Prevent heroes flying away")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Y Component Of(Position Of(Event Player)) > Global.MapBoundry_Vertical || Absolute Value(X Component Of(Position Of(
			Event Player))) > Global.MapBoundry_Horizontal || Absolute Value(Z Component Of(Position Of(Event Player)))
			> Global.MapBoundry_Horizontal) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Small Message(Event Player, Custom String("Don't stray too far"));
		If(Y Component Of(Position Of(Event Player)) > Global.MapBoundry_Vertical);
			Set Status(Event Player, Null, Frozen, 2);
		Else;
			"If character lives long enough for the freeze to expire during horizontal escape - they can fly away anyway so we just kill them (with longer freeze) to prevent it."
			Set Status(Event Player, Null, Frozen, 5);
		End;
	}
}

rule("Base: Ballance team sizes at round end")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBG != True;
		Global.IsRoundActive != True;
		Absolute Value(Number Of Players(Team 1) - Number Of Players(Team 2)) > 1;
	}

	actions
	{
		"Wait before all utility bots are destroyed"
		Wait Until(!Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element))), 1);
		"NOTE: in case of teams being 1:4 players it will take 2 rounds to ballance"
		Global.Temp[0] = Number Of Players(Team 1) - Number Of Players(Team 2);
		If(Global.Temp[0] > 1);
			Log To Inspector(Custom String("moving \"{0}\" to Team 2", Last Of(All Players(Team 1))));
			Move Player to Team(Last Of(All Players(Team 1)), Team 2, -1);
		Else If(Global.Temp[0] < -1);
			Log To Inspector(Custom String("moving \"{0}\" to Team 1", Last Of(All Players(Team 2))));
			Move Player to Team(Last Of(All Players(Team 2)), Team 1, -1);
		End;
	}
}

rule("Base: Prevent overly long 1v1s (if players waiting)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBG != True;
		Global.IsRoundActive == True;
		"Simply checking \"Number Of Living Players(Team X)\" is not enough because player who just joined and waits for round end will count towards the living"
		Count Of(Filtered Array(All Players(Team 1), Has Spawned(Current Array Element) && Is Alive(Current Array Element))) == 1;
		Count Of(Filtered Array(All Players(Team 2), Has Spawned(Current Array Element) && Is Alive(Current Array Element))) == 1;
		Number Of Players(All Teams) > 2;
		"Ignore if round is already near end"
		Match Time > 40;
	}

	actions
	{
		Abort If(Global.TimeLimit1v1_Countdown > -1);
		Log To Inspector(Custom String("1v1 time limit countdown start"));
		"This line is just to remove default countdown UI"
		Set Match Time(120);
		"XXX: this is quite unsightly"
		Wait Until(!Global.IsRoundActive || Count Of(Filtered Array(All Living Players(All Teams), !Is Dummy Bot(Current Array Element)))
			> 2, 10);
		If(Count Of(Filtered Array(All Living Players(All Teams), !Is Dummy Bot(Current Array Element))) > 2);
			Log To Inspector(Custom String("1v1 time limit prevented"));
			Abort;
		End;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Round ends in: {0} seconds", Global.TimeLimit1v1_Countdown),
			Top, 1, Color(White), Color(White), Global.TimeLimit1v1_Countdown > 10 ? Color(White) : Custom Color(250, 55, 65, 255),
			String and Color, Default Visibility);
		Global.TextIDS[0] = Last Text ID;
		For Global Variable(TimeLimit1v1_Countdown, 30, 0, -1);
			Wait Until(!Global.IsRoundActive, 1);
		End;
		Destroy HUD Text(Global.TextIDS[0]);
		Abort If(!Global.IsRoundActive);
		Log To Inspector(Custom String("1v1 time limit reached"));
		Declare Round Draw;
	}
}

rule("Base: Prevent premature game completion and skip victory screen")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DBG != True;
		Is Waiting For Players != True;
		(Number Of Players(Team 1) == 0 || Number Of Players(Team 2) == 0) == True;
	}

	actions
	{
		If(Number Of Players(All Teams) == 1);
			Small Message(All Players(All Teams), Custom String("Everyone left - restarting..."));
			Wait(1.500, Ignore Condition);
			"Skip victory screen on default victory when all but one players leave"
			Restart Match;
		Else;
			Global.Temp[1] = Last Of(All Players(All Teams));
			Log To Inspector(Custom String("immediately moving \"{0}\" to {1}", Global.Temp[1], Opposite Team Of(Team Of(Global.Temp[1]))));
			"XXX: it might make sense to also end match by declaring draw but that somehow doesn't trigger IsBetweenRounds (in this case) and no cleanup happens which is an issue"
			Move Player to Team(Global.Temp[1], Opposite Team Of(Team Of(Global.Temp[1])), -1);
		End;
	}
}

rule("Misc: HUD tip highlight")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsRoundActive == True;
	}

	actions
	{
		Global.HUDTipColor = Color(Orange);
		Wait(2, Ignore Condition);
		Global.HUDTipColor = Color(White);
	}
}

rule("Misc: Cleanup utility dummies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Although very rare, it is possible for a utility dummy (e.g. icicle grapple mei dummy) to not be deleted during game if the rule handling her is aborted (e.g. player leaving)"
		Is Dummy Bot(Event Player) == True;
		Slot Of(Event Player) > 3;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
	}
}

rule("Misc: Pre-game ult generation")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	conditions
	{
		"For the first ~3 seconds of the round ultimates to not generate so we have to calc it manually for some heroes during this"
		Global.IsRoundActive == True;
		Is Game In Progress == False;
	}

	actions
	{
		If(Hero Of(Event Player) == Hero(Soldier: 76));
			"Soldiers normal rounds do ~18 damage, we take this much for a +1% to charge"
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + Round To Integer(Event Damage / 20, Up));
		Else If(Hero Of(Event Player) == Hero(Cassidy));
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 1);
		End;
	}
}

rule("HP/Damage Balance: Powerup players belonging to smaller team")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsRoundStart == True;
		Number Of Players(Team Of(Event Player)) < Number Of Players(Opposite Team Of(Team Of(Event Player)));
	}

	actions
	{
		Abort If(Global.Powerup_PlayersNumAdvantage > 0);
		Global.Powerup_PlayersNumAdvantage = Number Of Players(Opposite Team Of(Team Of(Event Player))) - Number Of Players(Team Of(
			Event Player));
		Set Max Health(All Players(Team Of(Event Player)), 100 + Global.Powerup_HPPercent * Global.Powerup_PlayersNumAdvantage);
		Set Damage Dealt(All Players(Team Of(Event Player)), 100 + Global.Powerup_DamagePercent * Global.Powerup_PlayersNumAdvantage);
		Log To Inspector(Custom String("powerup x{1} {0} (evt:{2})", Team Of(Event Player), Global.Powerup_PlayersNumAdvantage,
			Event Player));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("{0} powered up!", Team Of(Event Player)));
	}
}

rule("Hero: Ana (self ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is Dummy Bot(Event Player) == False;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Hacked) || Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(
			Event Player, Stunned)) == False;
		(Hero Of(Event Player) == Hero(Ana) || Hero Being Duplicated(Event Player) == Hero(Ana)) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 0);
		Create Dummy Bot(Hero(Ana), Team Of(Event Player), 10, Vector(0, 0, 0), Vector(0, 0, 0));
		Set Invisible(Players In Slot(10, Team Of(Event Player)), All);
		Start Forcing Dummy Bot Name(Players In Slot(10, Team Of(Event Player)), Custom String("Ana Apparition"));
		Start Forcing Player Position(Players In Slot(10, Team Of(Event Player)), Position Of(Event Player) + Vector(0, 5, 1), False);
		Set Status(Players In Slot(10, Team Of(Event Player)), Null, Phased Out, 9999);
		Start Facing(Players In Slot(10, Team Of(Event Player)), Direction Towards(Players In Slot(10, Team Of(Event Player)),
			Event Player), 1000, To World, Direction and Turn Rate);
		Wait(0.400, Ignore Condition);
		Press Button(Players In Slot(10, Team Of(Event Player)), Button(Ultimate));
		"Support line for when Echo ults as Ana"
		Event Player.Echo_DupeUlted = True;
		Wait Until((Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) != True, 9);
		Destroy Dummy Bot(Team Of(Event Player), 10);
	}
}

rule("Hero: Hammond (icicle grapple - icicle spawning)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.Hammond_GrappleIsOn == False;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Hacked) || Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(
			Event Player, Stunned)) == False;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
	}

	actions
	{
		"Position of where a fake icicle should be created (what hammond is looking at)."
		Event Player.Hammond_IciclePos = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 13, All Players(All Teams), Event Player, True);
		"Prevent underground icicle"
		If(Y Component Of(Event Player.Hammond_IciclePos) < 0.700);
			Event Player.Hammond_IciclePos = Vector(X Component Of(Event Player.Hammond_IciclePos), 0.700, Z Component Of(
				Event Player.Hammond_IciclePos));
		End;
		Create Dummy Bot(Hero(Mei), Team Of(Event Player), 11, Event Player.Hammond_IciclePos - Vector(0, 0.300, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(11, Team Of(Event Player)), Custom String("Icicle"));
		Start Forcing Player Position(Players In Slot(11, Team Of(Event Player)), Position Of(Players In Slot(11, Team Of(Event Player))),
			True);
		Set Invisible(Players In Slot(11, Team Of(Event Player)), All);
		Wait(0.065, Ignore Condition);
		Press Button(Players In Slot(11, Team Of(Event Player)), Button(Ability 1));
		Wait(1, Ignore Condition);
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)), 3);
		Destroy Dummy Bot(Team Of(Event Player), 11);
	}
}

rule("Hero: Hammond (icicle grapple - when grapple disabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Absolute Value(X Component Of(Position Of(Event Player))) > 19.700 || Absolute Value(Z Component Of(Position Of(Event Player)))
			> 19.700 || Entity Exists(Players In Slot(11, Team Of(Event Player)))) == False;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Event Player.Hammond_GrappleIsOn = False;
		Disallow Button(Event Player, Button(Secondary Fire));
	}
}

rule("Hero: Hammond (icicle grapple - when grapple enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Absolute Value(X Component Of(Position Of(Event Player))) > 19.700 || Absolute Value(Z Component Of(Position Of(Event Player)))
			> 19.700 || Entity Exists(Players In Slot(11, Team Of(Event Player)))) == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		"If icicle was created"
		If(Entity Exists(Players In Slot(11, Team Of(Event Player))));
			Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.Hammond_IciclePos), 10000, To World,
				Direction and Turn Rate);
			"Allow some time for focus to snap onto icicle"
			Wait(0.170, Ignore Condition);
			Event Player.Hammond_GrappleIsOn = True;
			Allow Button(Event Player, Button(Secondary Fire));
			"Resetting ability triggers grapple to fire again when held"
			Set Secondary Fire Enabled(Event Player, False);
			Set Secondary Fire Enabled(Event Player, True);
			Stop Facing(Event Player);
		"If simply outside of island range"
		Else;
			Event Player.Hammond_GrappleIsOn = True;
			Allow Button(Event Player, Button(Secondary Fire));
		End;
	}
}

rule("Hero: Hammond (piledriver buff)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Crouch)) > 0;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Hero Of(Event Player) == Hero(Wrecking Ball) || Hero Being Duplicated(Event Player) == Hero(Wrecking Ball)) == True;
	}

	actions
	{
		Start Damage Modification(All Players(All Teams), Event Player, 210, Receivers Damagers and Damage Percent);
		Set Knockback Dealt(Event Player, 115);
		Wait Until(Vertical Speed Of(Event Player) == 0, 2);
		Wait(0.250, Ignore Condition);
		Stop All Damage Modifications;
	}
}

rule("Hero: Junkrat (mid-air ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		(Hero Of(Event Player) == Hero(Junkrat) || Hero Being Duplicated(Event Player) == Hero(Junkrat)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
		(Has Status(Event Player, Hacked) || Has Status(Event Player, Knocked Down) || Has Status(Event Player, Frozen) || Has Status(
			Event Player, Stunned)) == False;
	}

	actions
	{
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		Create Dummy Bot(Hero(Mei), Team Of(Event Player), 8, Position Of(Event Player) - Vector(0, 2.600, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(8, Team Of(Event Player)), Custom String("Icicle"));
		Set Invisible(Players In Slot(8, Team Of(Event Player)), All);
		Start Forcing Player Position(Players In Slot(8, Team Of(Event Player)), Position Of(Players In Slot(8, Team Of(Event Player))),
			False);
		Wait(0.065, Ignore Condition);
		Press Button(Players In Slot(8, Team Of(Event Player)), Button(Ability 1));
		Stop Forcing Player Position(Event Player);
		Wait Until(!Is In Air(Event Player), 1);
		Press Button(Event Player, Button(Ultimate));
		Destroy Dummy Bot(Team Of(Event Player), 8);
	}
}

rule("Hero: D.Va (start with an ult)")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		(Is Alive(Event Player) && Entity Exists(Event Player) && Global.IsRoundActive) == True;
	}

	actions
	{
		"NOTE: We are setting ult to 100% in the rules instead of settings because the setting makes her gain 100% ult every time she re-mechs."
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Hero: Soldier 76 (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Soldier: 76;
	}

	conditions
	{
		Global.IsRoundActive == True;
	}

	actions
	{
		"Value is tweaked with respect to \"Bugfix: pre-game ult generation\""
		Set Ultimate Charge(Event Player, 95);
	}
}

rule("Hero: McCree (start with some ult%)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Cassidy;
	}

	conditions
	{
		Global.IsRoundActive == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 98);
	}
}

rule("Hero: Lifeweaver (ult duration)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Global.IsRoundActive == True;
	}

	actions
	{
		Event Player.ChaserVar1 = 100;
		Event Player.Temp[0] = Eye Position(Event Player);
		Event Player.Temp[1] = Eye Position(Event Player) + Facing Direction Of(Event Player) * 40;
		"Wait for tree to spawn"
		Wait(0.250, Ignore Condition);
		"Cast ray from recorded eye position to recorded position these eyes were looking at, find a tree hit by the ray, shift found position upwards by 1 and away from eyes by 2 to center into tree trunk"
		Event Player.Temp[1] = Ray Cast Hit Position(Event Player.Temp[0], Event Player.Temp[1], Null, Null, True) + Facing Direction Of(
			Event Player) * Vector(2, 0, 2) + Vector(0, 1, 0);
		disabled Create Effect(All Players(All Teams), Sphere, Color(Red), Event Player.Temp[1], 1, None);
		Create Progress Bar In-World Text(All Players(Team Of(Event Player)), Event Player.ChaserVar1, Null, Event Player.Temp[1], 0.750,
			Do Not Clip, Custom Color(255, 235, 130, 255), Null, Values, Default Visibility);
		Event Player.TextIDS[0] = Last Text ID;
		Chase Player Variable Over Time(Event Player, ChaserVar1, 0, 7, None);
		Wait Until(Event Player.ChaserVar1 == 0, 15);
		Press Button(Event Player, Button(Ultimate));
		Destroy Progress Bar In-World Text(Event Player.TextIDS[0]);
	}
}

rule("Hero: Lifeweaver (ult duration - cleanup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		"XXX: normally there seems to be no way to reliably detect tree being destroyed, as a hacky workaround we just check if weaver starts building ult again, meaning there is no tree active"
		Ultimate Charge Percent(Event Player) > 0;
		Event Player.ChaserVar1 != 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, ChaserVar1);
		Destroy Progress Bar In-World Text(Event Player.TextIDS[0]);
	}
}

rule("Hero: Winstor (limit barrier HP)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Global.IsRoundActive == True;
		(Hero Of(Event Player) == Hero(Winston) || Hero Being Duplicated(Event Player) == Hero(Winston)) == True;
	}

	actions
	{
		Event Player.Temp[2] = Position Of(Event Player);
		"Atop the edge of shield border"
		Event Player.Temp[3] = Position Of(Event Player) + Vector(0, 5.400, 0);
		"We create a dummy bot in the opposite team for it to own the projectile. Granting ownership to null or arbitrary opposite team member has side effects and incosistencies."
		Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Event Player)), 7, Vector(0, -2, 0), Vector(0, 0, 0));
		Start Forcing Dummy Bot Name(Players In Slot(7, Opposite Team Of(Team Of(Event Player))), Custom String("Apparition"));
		Set Invisible(Players In Slot(7, Opposite Team Of(Team Of(Event Player))), All);
		Wait(0.100, Ignore Condition);
		Create Projectile(Orb Projectile, Players In Slot(7, Opposite Team Of(Team Of(Event Player))), Event Player.Temp[3],
			Direction Towards(Event Player.Temp[3], Event Player.Temp[2]), To World, Damage, Team Of(Event Player), 340, 0, 0,
			Bad Explosion, Explosion Sound, 0, 0.100, 0.200, 0, 0, 0);
		Wait(0.200, Ignore Condition);
		Destroy Dummy Bot(Opposite Team Of(Team Of(Event Player)), 7);
	}
}

rule("Hero: Echo (support others faux abilities)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Echo;
	}

	conditions
	{
		"Most of the support is added via hero specific rule conditions, this is currently just setup for later cleanup"
		Is Duplicating(Event Player) == True;
	}

	actions
	{
		Event Player.Echo_JustDuplicated = Hero Being Duplicated(Event Player);
		Event Player.Echo_DupeUlted = Null;
		Wait Until(Is Using Ultimate(Event Player) && Is Duplicating(Event Player), 9999);
		Event Player.Echo_DupeUlted = True;
	}
}

rule("Hero: Echo (support others faux abilities - cleanup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Echo;
	}

	conditions
	{
		Is Duplicating(Event Player) != True;
		Event Player.Echo_JustDuplicated != Null;
	}

	actions
	{
		Allow Button(Event Player, Button(Secondary Fire));
		If(Event Player.Echo_JustDuplicated == Hero(Ana) && Event Player.Echo_DupeUlted);
			Destroy Dummy Bot(Team Of(Event Player), 10);
		End;
		Event Player.Echo_JustDuplicated = Null;
	}
}

disabled rule("DBG: Main toggle")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DBG = True;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("DBG {0}", Global.DBGMsg), Right, 0, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("DBG: Enable hero select")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DBGAllowHeroSelect = 8;
	}
}

rule("DBG: Server load view toggler")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Event Player.ServerLoadVisible = !Event Player.ServerLoadVisible;
	}
}

rule("DBG: Persistent dummy bots")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DBG == True;
		Match Round == 1;
		Event Player == Host Player;
	}

	actions
	{
		Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 0, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 1, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 2, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zenyatta), Opposite Team Of(Team Of(Host Player)), 3, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 1, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 2, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Zarya), Team Of(Host Player), 3, Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

rule("DBG: Persistent bot shooting toggler")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Event Player == Host Player;
		Global.DBG == True;
	}

	actions
	{
		Global.DBGBotShooting = !Global.DBGBotShooting;
	}
}

rule("DBG: Persistent bot aim and shoot")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Slot Of(Event Player) == 0;
		Is Dummy Bot(Event Player) == True;
		Global.IsRoundActive == True;
		Global.DBGBotShooting == True;
	}

	actions
	{
		Start Facing(Event Player, Direction From Angles(90, 3), 100, To Player, None);
		While(True);
			Wait(2, Ignore Condition);
			If(Global.DBGBotShooting);
				Press Button(Event Player, Button(Primary Fire));
			End;
		End;
	}
}

rule("DBG: Melee actions (for dev drafts)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Melee)) == True;
		Global.DBG == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Melee DBG"));
	}
}